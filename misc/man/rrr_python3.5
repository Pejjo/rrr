.Dd 2019-10-04
.TH RRR 1
.SH NAME
Read Route Record is a dynamic module-based message handling program
for collecting, buffering, processing and storing messages and measurements.
.PP
.B rrr_helper
is a
.Xr python(1)
module which is available in python scripts run by RRR, see
.Xr rrr.conf(5)
and
.Xr rrr(1)
for information on how to run such a script. The module cannot be used outside
of RRR as this would make no sense.
.SH SYNOPSIS
These classes are available in python script when run by RRR.
.Dl from rrr_helper import rrr_socket
.Dl from rrr_helper import rrr_vl_message
.Dl from rrr_helper import rrr_array
.Dl from rrr_helper import rrr_array_value
.Dl from rrr_helper import rrr_setting
.PP
These 
.B handler functions
should be specified in a python script which is to be used by RRR.
.Dl def [NAME OF SOURCE FUNCTION](socket : rrr_socket):
.Dl def [NAME OF PROCESS FUNCTION](socket : rrr_socket, message : vl_message):
.Dl def [NAME OF CONFIG FUNCTION](socket : rrr_socket, setting : rrr_setting)
.SH LIBRARY CLASSES AND FUNCTIONS
.SS rrr_vl_message
Structure which contain a single RRR messsage which it is possible to mangle. A message may or may not contain a data
array.
.TP rrr_vl_message.set(type,class,timestamp_from,timestamp_to,data_numeric)
Set metadata of the message. The timestamps are times in epoch microseconds. The
.B data_numeric
parameter is an unsigned value
of the actual measurement. To validation is performed on the values other than them being positive integers.
.PP
Possible values for
.B type
are:
.Bl -tag -width -indent
.It rrr_vl_message.TYPE_MSG
.It rrr_vl_message.TYPE_ACK
.It rrr_vl_message.TYPE_TAG
.El
.PP
Possible values for
.B class
are:
.Bl -tag -width -indent
.It rrr_vl_message.CLASS_POINT
Point measurement, timestamp_from and timestamp_to are normally equal
.It rrr_vl_message.CLASS_AVG
Average measurement, starts at timestamp_from and ends at timestamp_to
.It rrr_vl_message.CLASS_MAX
Maximum measurement betweeen timestamp_from and timestamp_to
.It rrr_vl_message.CLASS_MIN
Minimum measurement betweeen timestamp_from and timestamp_to
.It rrr_vl_message.CLASS_INFO
Informational message, text might be put in the message body.
.It rrr_vl_message.CLASS_ARRAY
Message body contains a data array.
.El
The type
.B CLASS_ARRAY
is automatically set if the message contains an array, and any other data set in the message apart from in the header
is deleted.
.TP rrr_vl_message.set_data(data : bytearray|str)
Set the body of a message. If the message contains an array, this data will be discarded.
.TP rrr_vl_message.get_data()
Return the body of a message as a bytearray.
.TP rrr_vl_message.has_array()
Check if the message has an array or not, returns TRUE or FALSE.
.TP rrr_vl_message.get_array()
Return the array of a message, or create one if not already existing. The returned object of type
.B rrr_array
may be modified, and the message is updated accordingly.
.TP rrr_vl_message.set_array(array : rrr_array)
Discard an array from a message (if it has one) and set a new array in the message. 
.TP rrr_vl_message.discard_array()
Discard an array from a message (if it has one).
.TP rrr_vl_message.set_topic(topic : str)
Set the MQTT topic of a message.
.TP rrr_vl_message.get_topic()
Return the MQTT topic of a message. If there is no topic, return an empty string.
.SS rrr_array
This class allows for modification of the array part of a message, or creation of a new one. An array consist
of multiple members, optionally with a tag to identify them. Each member may itself have multiple values, but these
values must then be of the same size.
.PP
The
.B rrr_array
object may be iterated.
.TP rrr_array.count()
Count the members in the array.
.TP rrr_array.get(tag : str|int)
Get a member by textual tag or numeric index. Returns an
.B rrr_array_value
object or NONE.
.TP rrr_array.append()
.SS rrr_array_value

.TP rrr_array.set(tag )


.SS rrr_socket
To communicate with RRR in its python module, a UNIX socket is used "behind the scenes" over which messages
are sent in both directions.
.PP
When a
.B handler function
is called by RRR, it receives an
.B rrr_socket
object which is already connect to RRR, and it's possible to send messages immediately. It is also possible to set
up sockets manually to send data somewhere (
.Xr rrr_post(1)
would be able to read such messages). It is not possible to read messages from the socket.
.TP rrr_socket()
The initializer takes no arguments.
.TP rrr_socket.start([filename])
Create a new socket. If a filename is provided, connect to an existing socket. If not, create a new socket and listen for
incoming connections. The filename of the socket is generated automatically.
.TP rrr_socket.get_filename()
Get the filename of the socket.
.TP rrr_socket.send(object : rrr_vl_message|rrr_socket)
Send a
.B rrr_vl_message
or
.B rrr_setting
object on the socket.
.TP rrr_socket.accept()
Accept a connection (for listening socket only).
