.Dd 2020-04-16
.TH RRR.CONF 5
.SH NAME
Read Route Record is a dynamic module-based message handling program
for collecting, buffering, processing and storing messages and measurements.
.SH DESCRIPTION
The
.B rrr
environment is set up with a configuration file. The file specifies any number
of
.B instances
of different
.B modules.
The different instances either get messages from other
modules or read them externally. Some also save messages externally or
send them over the network.
.PP
Instances are linked to each other using the 
.B senders=instance1,...
configuration parameter, which tells the instance which other modules to get messages from. A
.B source
module is a module which cannot read from other modules, and this argument should
not be specified.
.PP
At program startup, the order of module start can be controlled using the
.B wait_for=instance_1,...
configuration parameter. The instance with this argument will not be started until the
other specified instances have started.
.PP
.B rrr
may be extended with custom modules. Custom functionality may also be achieved by
using a module which can send data to and from a python program.
.PP
.B rrr
automatically restarts all running instances in case one instance for any
reason stops or hangs, like due to network problems. A failing instance
usually does not make
.B rrr
quit, all instances are simply restarted.
.PP
.SH SYNTAX
Any number of instances may be specified. An instance specification begins with a [] containing
the user chosen name of the instance. A module to use must then be specified, along with
module-specific settings. The
.B senders=
setting is mandatory for modules which read from other modules, but invalid for modules
which are sources (see MODULES section). An instance section ends when a new begins
or when we reach the end of the file.
.PP
.nf
# Comment begins with #, the rest of the line is ignored
[INSTANCE_1_NAME]             # User chosen name of the instance
module={MODULE NAME}        # Which module to use for the instance
senders=INSTANCE NAME,...   # Which other instances to read from (not for source modules)
wait_for=WAIT FOR,...       # On program startup, wait for these instances to start before starting
argument1=value1            # Module-specific arguments

[INSTANCE_2_NAME]
module=...
.PP
If an instance is specified as sender in more than one other instance, these will compete
about messages from it. Instances may not use themselves as senders.
.SH MESSAGES
A message consists of at least a timestamp (in microseconds) and either arbitary data or
and array of values.
.SS DATA MESSAGES
A data message is a message which arbitary data in it.
.SS ARRAY MESSAGES
Some modules support parsing data arrays from externally or from other modules. They might require a
list of expected data types to be specified in their configuration. If the total size of the input
does not match the received input, parsing of the message will fail.
.PP
The general syntax is a comma separated list of types with length and item count specifications. 
.PP
.DlÂ type1[length1][@count1][#tag1][,type2[length2][@count2][#tag2]][,...]
.PP
Refer to the
.B ARRAY DEFINITION
section of
.Xr rrr_post(1)
for the complete specification of all the types.
.SS IP MESSAGES
Some modules support parsing of IP messages. These are simply normal messages apart from that they also contain information
about the originating IP addresses. They are used for instance when sending replies back to a sender over network to know
where to send them. Some modules require that readers are IP capable when reading from them and vice versa. Some modules
are also flexible and may accept or give out either.
.SH MODULES
.PP
Modules have different special capabilites, denoted by the following letters. The actual implementation may
vary between modules. Many modules can despite this handle all types of messages, more or less ignoring their contents.
.PP
.Bl -tag -width -indent
.It S
Source module, cannot have senders
.It P
Processor modules, can have senders specified to read from (set with
.B senders=
)
.It D
Dead-end module, cannot be used as sender
.It N
Network-oriented module, cannot be used as sender nor have senders specified itself.
.It A
Module supports data arrays (see above)
.It I
Module supports IP messages
.El
If
.B A
is not specified for a module, it doesn't care about the contents of messages but simply forwards them. 
.PP
The following modules and module-specific arguments are available and can be used
.PP
.SS dummy (S)
Constantly generates empty messages only with a timestamp set.
.PP
.Bl -tag -width -indent
.It dummy_no_generation={yes|no}
No messages are generated, defaults to yes. 
.It dummy_no_sleeping={yes|no}
Don't sleep between creating messages, but create as many messages as the reader can handle. Defaults to no.
.It dummy_max_generated={unsigned number}
Stop generating messages after this number is reached. 0 value or not defined means that generation will not stop.
.It dummy_random_payload_max_size={BYTES}
When generating messages, give them an empty payload with a random size in the range 0 to BYTES. Default is 0 (no payload for messages).
.El
.SS udp (PAI)
This module is capable of listening on an UDP port and read messages or arrays, as well as sending data to remote hosts.
A message is created for each received packet and a timestamp is added.
If the received data does not match the specified data array, the packet is dropped.
.PP
If an instance is configured to wait for and udp module before starting, the udp module set up any listening sockets before the
waiting instance is started.
.Bl -tag -width -indent
.It udp_port=LISTEN PORT
Port to listen on and also source port for outbound messages, range is 1-65535.
If left unspecified, no listening takes place.
.It udp_input_types=ARRAY DEFINITION
Specification of expected data to receive from remote. See
.Xr rrr_post(1)
for the syntax. No listening takes places unless this is specified.
To receive RRR messages, simply set the definition to
.B msg
and set
.B udp_extract_rrr_messages
to
.B yes.
.It udp_extract_rrr_messages={yes|no}
Extract any RRR messages from the received data (if specified in udp_input_types) and save them in the buffer for other modules to pick up.
Causes any other data in the received arrays to be dropped.
If set to yes and no message field is specified in the array definition, an error will be produced.
Defaults to no.
.It udp_default_topic=MQTT-TOPIC
An optional MQTT topic to set on the generated messages.
.It udp_sync_byte_by_byte={yes|no}
If array parsing fails according to definition, keep skipping one byte forward in the stream until a match is found.
Defaults to no, which means to only sync on boundaries of incoming messages.
.It udp_send_rrr_message={yes|no}
If set to yes, UDP will send complete RRR messages encoded for network. If set to no or left unset,
messages with arrays will have their array packed and sent, and messages with other data will simply have their
contents sent as is.
.It udp_target_host=HOST
.It udp_target_port=PORT
Default target host and port for messages from other modules which do not contain address information.
If left unset and UDP recevies messages which do not contain address information, the messages are dropped
and warning messages are produced.
.It udp_force_target={yes|no}
Use the specified target host and port even if messages contain other address information. Default is no.
.It udp_array_send_tags=tag1[,tag2[,...]]
Look for the defined tags in array messages from other modules, and send these concatenated together to remote.
If this option is specified and a received message is not an array or does not have all of the tags defined,
the message is dropped and an error message is produced.
If this option is left unspecified, all values from arrays are sent, and messages which are not arrays will have their raw data sent if any. 
.El
.PP
.SS voltmonitor (SA)
Read voltage readings from a USB device. For every reading, an array message is generated with the timestamp of the measurement
and the measurement itself as an unsigned 64-bit integer with the tag
.B measurement.
.PP
.Bl -tag -width -indent
.It vm_calibration=FLOAT
Factor to calibrate the readings, defaults to 1.124.
.It vm_channel={1|2}
Which channel to use on two-channel devices.
.It vm_message_topic=TOPIC
MQTT topic to apply to generated messages.
.El
.PP
.SS averager (PA)
The averager module reads point measurements from it's senders and produces average measurments over a given timespan and
at a given rate. Other messages are simply passed through.
.PP
The averager module expects to find the tag
.B measurement
in array messages from it's senders. It will generate average measurements with the following values as unsigned 64-bit integers:

.Bl -tag -width -indent
.It average
The average of the measurements received in the timespan.
.It max
The maximum value of all the measurements received in the timespan.
.It min
The minimum value of all the measurements received in the timespan.
.It timestamp_from
The lowest timestamp of all the measurements received in the timespan.
.It timestamp_to
The highest timestamp of all the measurements received in the timespan.
.El
.PP
.Bl -tag -width -indent
.It avg_timespan=SECONDS
How long timespan to average over. Defaults to 15 seconds.
.It avg_interval=SECONDS
How often to produce average calculations. Defaults to 10 seconds.
.It avg_preserve_points={yes|no}
Preserve individual measurements and put them in output buffer. Defaults to no.
.It avg_discard_unknowns={yes|no}
Delete messages which are not point measurements and information messages. Defaults to no, which means to simply forward them.
.It avg_message_topic=TOPIC
MQTT topic to apply to generated messages and any forwarded point messages.
.El
.SS buffer (P)
The buffer collects all messages from all senders and wait for them to be collected by another instance.
.SS duplicator (P)
The duplicator works like buffer only that it creates one output buffer for every reader and duplicates the
data it reads from other modules for each reader. The readers of duplicator are detected automatically.
.SS ipclient (PI)
The ipclient module collects any messages from senders and sends them over the network to another 
.B RRR
environment's ipclient module using UDP. It may also accept connections from other clients and receive data,
or a combination of these. An underlying UDP stream protocol ensures single delivery of
all messages (similar design as MQTT QOS2), and messages are checksummed with a CRC32 algorithm.
.PP
.B ipclient is not secure in any way and must only be used on closed networks!
.PP
After an ipclient instance has connected to a remote ipclient, the remote will accept packets, and the connection
persists even if the connecting clients IP-address changes unless specified otherwise in the configuration.
.PP
Please not that ipclient is not designed to receive connections and packets from arbitary remote hosts.
If a remote sends packets and does not complete the acknowledgement handshakes, the packets will persist in memory.
.PP
If a remote host becomes unavailable for a longer period of time, unfinished acknowledgement handshakes
are re-initiated when it becomes available again, even if it has been re-started in the mean time.
.PP
ipclient will not accept incoming connections from other clients unless explicitly told to in the configuration file.
.PP
.Bl -tag -width -indent
.It ipclient_client_number=NUMBER
Each ipclient instance in a set of instances which communicate together must have a unique ID number in the range 1-4294967295.
If you have two instances running, set one of them to 1 and the other one to 2.
.It ipclient_default_remote=REMOTE NAME OR ADDRESS
The name or address of the client which we send packets without address information to.
.It ipclient_default_remote_port=PORT NUMBER
The port number of the default remote, defaults to 5555.
.It ipclient_src_port=PORT NUMBER
Source port used for sending and receiving packtes, defaults to 5555.
.It ipclient_listen={yes|no}
Accept incoming connections if set to yes. Default is no.
.It ipclient_disallow_remote_ip_swap={yes|no}
If yes and a remote changes its IP-address, RRR must restart before the new address can be accepted. Default is no. 
.El
.SS mysql (DAI)
This module will read in messages from other modules, possibly IP-capable, and save them to a myqsl or MariaDB 
database.
.PP
A column plan must be used to describe the table we are saving to. The received data must match this column plan. If
the data saving for any reason fails, like if the database is down or the table is misconfigured, we cache the failed messages
and try again later. It is not possible for the mysql module to know wether it's settings are at fault or if the database
is at fault. Messages which fails can regardless of this be set to be dropped instead upon errors.
.Bl -tag -width -indent
.It mysql_server=SERVER NAME
The server name of the MySQL or MariaDB server to use
.It mysql_port=PORT NUMBER
The port number used to connect to the server.
.It mysql_user=USER NAME
The username for logging into the server
.It mysql_password=PASSWORD
The password for logging into the server
.It mysql_db=DATABASE NAME
The name of the database to use
.It mysql_table=TABLE NAME
The table name to use for storing data
.It mysql_drop_unknown_messages={yes|no}
If a message fails to be saved into the specified table for any reason, simply delete it instead of trying again later. Defaults to no.
.It mysql_columns={column name 1,column name 2,...}
Specify the columns in the table to write data to. The column count must match the number of values received in array
messages from other modules. The data types only matters to some extent, the columns should be able to hold the data
types received. Integers are sent to the database as integers and blobs are sent as blobs.
If an array contains items with more than one value, one column should be specified for the whole item. These items are always sent
to mysql as blobs.
This option cannot be used with
.B mysql_column_tags.
.It mysql_column_tags=ARRAY TAG[->MYSQL COLUMN][,...]
A comma separated list of items to retrieve from the received array messages and to use as
columns in MySQL. If a tag name is specified on is own, the tag and the corresponding column in MySQL has the same name.
If the MySQL column name is different from the tag, an arrow followed by the MySQL column name is put after the tag name.
This option cannot be used with
.B mysql_colums.
.It mysql_blob_write_columns={column name 1,column name 2,...}
Used to force to send data as blob (raw data) to the database for the specified columns regardless of their type.
.It mysql_special_columns={column1=value1,column2=value2,...}
Used to write fixed values to the database.
.It mysql_add_timestamp_col={yes|no}
In addition to the other columns, write to a column named `timestamp` and save the timestamp from the message here.
.It mysql_strip_array_separators={yes|no}
Disregard any separator items in received array messages. Defaults to yes.
.El
.SS python3 (P)
This module can send messages to a custom python program and read them back.
All messages read from the senders are sent to the python program to the process function specified.
A read-only source function may also be specified if the python program should only generate messages by itself and not receive any.
It is possible to specify both source- and process-functions at the same time.
Functions should return 0 on success and put any messages into the result class provided in the argument.
If something goes wrong, the functions can return 1 or raise an exception which makes RRR stop all running instances and restart.
.PP
The RRR module should be imported by the custom python program, but is in only available when the python script is called from RRR.
.PP
The following options may be specified:
.Bl -tag -width -indent
.It python3_module=MODULE NAME
The module name for the python3 program to be executed. Imported by 'from MODULE NAME import *'
.It python3_module_path=MODULE NAME
An extra path in which to search for the module.
.It python3_source_function=FUNCTION NAME
The name of the source function in the python program which we read from continously.
.It python3_process_function=FUNCTION NAME
The name of the processing function in the python program which we send packets from other modules to. We also read any messages sent back.
.It python3_config_function=FUNCTION NAME
The name of the function in the python program to which we send settings form the configuration file.
All settings defined inside the python block in the configuration file are sent in here.
The function might also notify that settings have been accessed to avoid warnings.
The config function is called once for every setting.
.It CUSTOM SETTING=VALUE
Any number of custom settings for the python program might be set as needed.
.El
.PP
Below follows an example python message processing and generating program. A socket is used to
post messages. The process and source functions have their own environments, and they will not
share any global variables set by the config function. The config function is called first in
the process environment, then in the source environment.
.PP
.nf
from rrr_helper import *
import time

my_global_variable = ""

def config(socket : rrr_socket, rrr_setting : setting):
	global my_global_variable

	# retrieve some custom settings from configuration file. The get()
	# will update the "was-used" flag in the setting.
	print ("Received a setting: " + setting.name + "=" + setting.get())

	# set a global variable
	if setting.name == "my_setting":
		my_global_variable = setting.get()

	# send settings back to update which have been read (optional)
	socket.send(setting)
	
	return True

def process(socket : rrr_socket, message: rrr_message):
	# Return False if something is wrong
	if my_global_variable == "":
		print("Error: configuration failure")
		return False
		
	# modify the retrieved message as needed
	message.timestamp = message.timestamp + 1
	
	# queue the message to be sent back (optional) for python to give to readers
	socket.send(message)
	
	return True

def source(socket : rrr_socket):
	# create a new message
	message = rrr_message(1, 2, 3, 4, 5, 6, bytearray("abcdefg", encoding='utf8'))
	
	# queue the message to be sent back (optional) for python to give to readers
	socket.send(message)
	
	# sleep to limit output rate
	time.sleep(1)

	return True
	
.fi
More details about Python in 
.Xr rrr_python3(5)
.PP
.SS perl5 (PAI)
The perl5 module makes it possible to process and generate messages in a custom 
perl script. The first and only argument to the source- and generate-functions
is the RRR message in the form of a hash with different parameters which may be
modified as needed. To pass the message back to RRR, the
.B send()-method
of the message must be called. If the message should not be passed on, simply skip
the call to this method. The method may be called multiple times if required.
.PP
It is possible to work with RRR array messages in the Perl script. This is done by
adding values to or removing values from three control arrays which are always defined
in a message hash. The number of elements in these arrays must always be equal, this is
strictly enforced. Each array item is this defined by having a value in each of the three
control arrays. An array value must be at the same position in each of the three arrays.
.PP
If the control arrays have no values, the message will not be treated as an array message in RRR.
.PP
The three control arrays in the message hash are:
.Bl -tag -width -indent
.It array_values
The actual data of each array value. If an array value has multiple data values, they must be put inside another array and a reference to this must be set in array_values.
.It array_tags
The tag of the array value. Set an empty string if no tag is to be set.
.It array_types
The type of the value in string form. Possible values are
.B str
(string value),
.B h
(integer value),
.B fixp
(fixed pointer value),
.B ustr
(unsigned number as string),
.B istr
(signed number as string),
.B nsep
(non-separator/whitespace characters),
.B sep
(a separator character),
.B blob
(binary data) and
.B msg
(complete encoded RRR message)
.El
More details about types are found in 
.Xr rrr_post(1)
.PP
.Bl -tag -width -indent
.It perl5_file=FILENAME
Path and filename of the perl script to use. The script is run once when the program starts,
which means that code may be added outside the three subroutines mentioned below.
.It perl5_source_interval=MILLISECONDS
How long to wait between each call of the source subroutine (if defined). Defaults to 1000 ms.
.It perl5_source_sub=SUBROUTINE NAME
Optional name of a subroutine which receives an rrr::rrr_helper::rrr_message object and modifies
it to generate a new message. Called at specified interval.
.It perl5_process_sub=SUBROUTINE NAME
Optional name of a subroutine which receives an rrr::rrr_helper::rrr_message object from the senders
of the current instance. The message may be modified or left alone.
.It perl5_config_sub=SUBROUTINE NAME
Optional name of a subroutine which receives an rrr::rrr_helper::rrr_settings object when the program
is started. Any settings from the instance definition in the configuration file can be read from
this object, also custom settings. Settings may also be modified and new settings can be added. The
settings object may also be stored in the script to be read from or modified from the source- and 
generate-subroutines.
.PP
.B NOTE:
Any modified settings will currently not be visible in the perl5 RRR module, only in the perl5 script.
.El
.PP
There must always be either a source- or process subroutine specified, or both. If a process subroutine
is specified, there must also be at least one sender specified.
.PP
If a Perl instance receives messages from an IP-capable module, like
.B udp,
the address information of the original sender of a message is retained. Other IP-capable modules may
then use this information if they read data from the Perl instance, for example if you wish to use
a Perl script to generate a reply message to some remote host. There is no high-level method for modifying
the address information inside the Perl script, but the values
.B originating_addr
and
.B originating_addr_len
are to be found in the message hash. The values are filled with data from
.B struct sockaddr
and
.B socklen_t
which is provided by the operating system. These two values may be saved and re-used in later messages,
or they may be modified if you know how to do that (not documented here).
.PP
Below follows an example perl script.
.PP
.nf
#!/usr/bin/perl -w

package main;

use rrr::rrr_helper;
use rrr::rrr_helper::rrr_message;
use rrr::rrr_helper::rrr_settings;

my $global_settings = undef;

sub config {
	# Get the rrr_settings-object. Has get(key) and set(key,value) methods.
	my $settings = shift;

	# If needed, save the settings object
	$global_settings = $settings;

	# Custom settings from the configuration file must be read to avoid warning messages
	# print "my_custom_setting is: " . $settings->get("my_custom_setting") . "\\n";

	# Set a custom setting
	$settings->set("my_new_setting", "5");

	# Return 1 for success and 0 for error
	return 1;
}

sub source {
	# Receive a newly generated template message
	my $message = shift;

	# Do some modifications
	$message->{'timestamp'} = $message->{'timestamp'} - $global_settings->get("my_custom_setting");

	# print "source:  new timestamp of message is: " . $message->{'timestamp'} . "\\n";

	# Pass on the new message
	$message->send();

	# Return 1 for success and 0 for error
	return 1;
}

sub process {
	# Get a message from senders of the perl5 instance
	my $message = shift;

	# Do some modifications to the message
	$message->{'timestamp'} = $message->{'timestamp'} - $global_settings->get("my_custom_setting");

	# print "process: new timestamp of message is: " . $message->{'timestamp'} . "\\n";

	# Push an array value to the message array
	push @{$message->{'array_values'}}, "My array string value";
	push @{$message->{'array_tags'}}, "tag_for_string_value";
	push @{$message->{'array_types'}}, "str";

	# Set some integer values
	my @my_integers = (1, 2, 3, 4);
	
	# Push the integer values into the message array. Remember the backslash to make a reference.
	push @{$message->{'array_values'}}, \\@my_integers;
	push @{$message->{'array_tags'}}, "tag_for_integer_value";
	push @{$message->{'array_types'}}, "h"; 

	# Pass on the modified message
	$message->send();

	# Return 1 for success and 0 for error
	return 1;
}
.fi
.SS raw (PI)
This module simply drains data from it's senders and deletes it after printing a message if debugging is active. It
can read from both IP modules and non-IP.
.PP

.Bl -tag -width -indent
.It raw_print_data={yes|no}
Print the timestamp of each received message and dump any arrays present in the messages.
.El
.SS socket (SA)
The socket module listens on a UNIX socket for RRR messages or custom data records.
.PP
.Bl -tag -width -indent
.It socket_path=FILENAME
Path and file name to use for the socket. The file cannot exist when the program starts. 
.It socket_default_topic=MQTT-TOPIC
An optional MQTT topic to set on the generated messages.
.It socket_receive_rrr_message={yes|no}
If set to 
.B yes
, complete RRR messages are expected to be received on the socket. No array definition is to be specified. 
.Xr rrr_post(1)
may generate such messages. If set to 
.B no
, an array definition must be specified, and RRR array messages will be produced from the received data. Defaults to no.
.It socket_input_types=ARRAY DEFINITION
Format of data received on the socket, see
.Xr rrr_post(1)
for syntax.
.It socket_sync_byte_by_byte={yes|no}
If array parsing fails according to definition, keep skipping one byte forward in the stream until a match is found.
Defaults to no, which means to only sync on boundaries of incoming messages.
.El
.SS influxdb (DA)
This module receives array messages from other modules and sends their data to an Influx database using HTTP.
 
.Bl -tag -width -indent
.It influxdb_server=HOSTNAME
The IP address or hostname of the host running an Influxdb database.
.It influxdb_database=DATABASE
The database name to use on the server.
.It influxdb_table=TABLE
The table in the database in which to store the data.
.It influxdb_port=PORT
An optional port to connect to on the server, defaults to 8086.
.It influxdb_tags=ARRAY TAG[->INFLUXDB TAG][,...]
A comma separated list of items to retrieve from the received array messages and which should be used as
.B tags
in InfluxDB. If the tag of an
item in an array is not equal to the tag in InfluxDB, the tag may be followed by
.B ->INFLUXDB TAG
to translate the tag name. 
Items in an array message which are not tagged cannot be used.
.It influxdb_fields=ARRAY TAG[->INFLUXDB FIELD][,...]
A comma separated list of items to retrieve from the array and which are to be used as
.B fields
in InfluxDB. Otherwise same rules as for tags.
.It influxdb_fixed_tags=TAG[=VALUE][,...]
Optional comma separated list of fixed tags (and optionally with values) to save to InfluxDB.
.It influxdb_fixed_fields=FIELD[=VALUE][,...]
Optional comma separated list of fixed fields (and optionally with values) to save to InfluxDB.
.El
It is required to have at least one tag specified in either
.B influxdb_fields
or
.B influxdb_fixed_fields
.
.SS mqttbroker (N)
An MQTT broker supporting V3.1(.1) and V5 (lacking some functionallity).
.PP
.Bl -tag -width -indent
.It mqtt_server_port=PORT
TCP port to listen on (listens on all interfaces). Defaults to 1883.
.It mqtt_server_max_keep_alive=SECONDS
Maximum keep-alive value for clients, defaults to 30.
.It mqtt_server_retry_interval=SECONDS
Retry interval for QoS1 and QoS2 messages.
.It mqtt_server_close_wait_time=SECONDS
After disconnect, wait this many seconds before closing the socket (make client close first to avoid TIME_WAIT). Defaults to 1 second.
.El
.PP
The MQTT server follows the specifications from Oasis, but lacks support for the following (will be implemented shortly):
.PP
.Bl -tag -width -indent
.It UNSUBSCRIBE messages
.It Retained topics
.It Will topics
.It Encryption
.It Authorization
.El
.SS mqttclient (P)
An MQTT client supporting V3.1.1 and V5. The client will publish RRR messages it receives from other modules, and
other modules can read messages the client receives on subscribed topics.
.PP
.Bl -tag -width -indent
.It mqtt_server=HOST
Host name or IP of the broker to connect to. Defaults to localhost.
.It mqtt_server_port=PORT
TCP port on the server, defaults to 1883.
.It mqtt_client_identifier=IDENTIFIER
Client identifier to use. If left unspecified, broker pics one.
.It mqtt_connect_error_action={restart|retry}
Default action if connecting to the server failed. If set to
.B restart,
all RRR modules will be restarted after a few connection attempts (might cause messages to be lost). If set to
.B retry,
the client will keep trying to connect without any restart (messages will not be lost). Default action is to restart.
.It mqtt_connect_attempts=NUMBER OF ATTEMPTS
How many times we attempt connecting to the broker before giving up.
What we do when this number is reached depends on the setting
.B mqtt_connect_error_action.
One connection attempt lasts approximately 100ms. Must be 1 or more, defaults to 20.
.It mqtt_qos={0|1|2}
Default Quality of Service to use, defaults to 1.
.It mqtt_version={3.1.1|5}
Default MQTT protocol version to use, defaults to 3.1.1.
.It mqtt_publish_topic=TOPIC
Topic to use when publishing RRR messages without topic set in them.
If left unspecified, RRR messages without a topic will be dropped.
.It mqtt_publish_topic_force={yes|no}
Force use of the topic specified in
.B mqtt_publish_topic
and disregard any topic in RRR messages.
.It mqtt_publish_rrr_message={yes|no}
If set to yes, the client will send full RRR messages.
If set to no, only the measurement value of each RRR message will be sent as a string. Defaults to yes.
.It mqtt_publish_array_values={*|tag1[,tag2[,...]]}
Put all values from an array (*) or selected values (by tag) into the payload of PUBLISH messages. RRR
messages which does not contain an array are dropped. Any integer types will have big endianess. Cannot be used with
.B mqtt_publish_rrr_message=yes.
.It mqtt_subscribe_topics=TOPIC1[,TOPIC2[,...]]
MQTT topic patterns to subscribe to (if any).
.It mqtt_receive_rrr_message={yes|no}
Expect to receive RRR messages from the broker.
If set to yes, any messages received which are not RRR messages are dropped.
If set to no and protocol version is V3.1.1, any data in messages received are put into a new RRR message.
If set to no and protocol version is V5, type of the received message is auto-detected.
Defaults to no.
.It mqtt_receive_array=ARRAY DEFINITION
If set, expect to receive data arrays of specific formats in publish messages.
This option cannot be used with mqtt_receive_rrr_message=yes, however if protocol version is V5,
received RRR messages will still be auto-detected, and array parsing will not occur for these.
Multiple data array records may reside in a single PUBLISH message, one RRR message will be generated for each record. 
Refer to
.Xr rrr_post(1)
for syntax of array definitions.
Defaults to yes.
.El

.SH SEE ALSO
.Xr rrr(1),
.Xr rrr_post(1),
.Xr rrr_python3(5)
