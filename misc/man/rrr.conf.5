.Dd 2020-07-11
.TH RRR.CONF 5
.SH NAME
Read Route Record is a dynamic module-based message handling program
for collecting, buffering, processing and storing messages and measurements.
.SH DESCRIPTION
The
.B rrr
environment is set up with a configuration file. The file specifies any number
of
.B instances
of different
.B modules.
The different instances either get messages from other
modules or read them externally. Some also save messages externally or
send them over the network.
.PP
Instances are linked to each other using the 
.B senders=instance1,...
configuration parameter, which tells the instance which other modules to get messages from. A
.B source
module is a module which cannot read from other modules, and this argument should
not be specified.
.PP
At program startup, the order of module start can be controlled using the
.B wait_for=instance_1,...
configuration parameter. The instance with this argument will not be started until the
other specified instances have started.
.PP
.B rrr
may be extended with custom modules. Custom functionality may also be achieved by
using a module which can send data to and from a python program.
.PP
.B rrr
automatically restarts all running instances in case one instance for any
reason stops or hangs, like due to network problems. A failing instance
usually does not make
.B rrr
quit, all instances are simply restarted.
.PP
.SH SYNTAX
Any number of instances may be specified. An instance specification begins with a [] containing
the user chosen name of the instance. A module to use must then be specified, along with
module-specific settings. The
.B senders=
setting is mandatory for modules which read from other modules, but invalid for modules
which are sources (see MODULES section). An instance section ends when a new begins
or when we reach the end of the file.
.PP
.nf
# Comment are like this, the rest of the line is ignored. The instance name
# and module name are the ony parameters which are always required.

[INSTANCE_1_NAME]    # User chosen name of the instance
module={MODULE NAME} # Which module to use for the instance

# Which other instances to read from (not for source only modules)
senders=INSTANCE NAME,...

# On program startup, wait for these instances to start before starting (optional)
wait_for=WAIT FOR,...

# Drop all messages from senders which do not match the set topic (optional)
topic_filter=MQTT TOPIC FILTER

# Module-specific arguments (module-dependant)
argument1=value1

[INSTANCE_2_NAME]
module=...
.PP
If an instance is specified as sender in more than one other instance, these will compete
about messages from it. Use the
.B duplicator
module if a message is to be processed by multiple modules, for instance when different modules should process messages
with different topics. Instances may also not use themselves as senders.
.SH MESSAGES
A message consists of at least a timestamp (in microseconds) and either arbitary data or
and array of values. Messages may in addition contain an MQTT topic which can be used internally by certain modules.
.PP
Messages can either contain arbitary data or a data array.
.PP
Modules which support parsing data arrays from externally or from other modules might require a list of expected data
types to be specified in their configuration. If the total size of the input does not match the received input, parsing
of the message will fail. Some modules also generate array messages internally, and they can be created within Perl and
Python scripts. Fields from an HTTP request can be mapped into an array, and an array can be mapped into database columns.
.PP
The general syntax for an array parsing specification is a comma separated list of types with length and item count specifications. 
.PP
.DlÂ type1[length1][@count1][#tag1][,type2[length2][@count2][#tag2]][,...]
.PP
Refer to the
.B ARRAY DEFINITION
section of
.Xr rrr_post(1)
for the complete specification of all the types.
.SS IP MESSAGES
Some messages contain IP data, for instance messages created by a module which reads from the network. The address
of the sender will be contained within the message. All modules may use IP-messages, but not all of them use the IP-data. 
.SH MODULES AND CONFIGURATION PARAMETERS
.PP
Modules have different special capabilites, denoted by the following letters. The actual implementation may
vary between modules. Many modules can despite this handle all types of messages, more or less ignoring their contents.
.PP
.Bl -tag -width -indent
.It S
Source module, can't read from other modules
.It P
Processor module, can have senders specified to read from (set with
.B senders=
) and may also be read from by other modules
.It D
Dead-end module, can only read from other modules
.It N
Network-oriented module, cannot be used as sender nor have senders specified itself.
.It A
Module supports data arrays (see above)
.It I
Module supports IP messages
.El
.PP
All modules support array and/or IP-messages, also those who do not have  
.B A
or
.B I
specified. Array- and IP-capable modules may however use or modify data from such messages.
.PP
A message may have both IP- and Array-data simultaneously. 
.PP
The following modules and module-specific arguments are available:
.PP
.SS dummy (S)
This module constantly generates empty messages, optionally containing some dummy data.
.PP
.Bl -tag -width -indent
.It dummy_no_generation={yes|no}
No messages are generated, defaults to yes. 
.It dummy_no_sleeping={yes|no}
Don't sleep between creating messages, but create as many messages as the reader can handle. Defaults to no.
.It dummy_max_generated={unsigned number}
Stop generating messages after this number is reached. 0 value or not defined means that generation will never stop.
.It dummy_random_payload_max_size={BYTES}
When generating messages, give them an empty payload with a random size in the range 0 to BYTES. Default is 0 (no payload for messages).
.It dummy_topic={TOPIC}
Set an MQTT topic in generated messages.
.El
.SS ip (PAI)
This module is capable of listening on an UDP or TCP port and read messages or arrays, as well as sending data to remote hosts.
A message is created for each received packet and a timestamp is added.
If the received data does not match the specified data array, the packet is dropped.
.PP
If an instance is configured to wait for this module before starting, the we will set up any listening sockets before the
waiting instance is started.
.PP
.Bl -tag -width -indent
.It ip_udp_port=LISTEN PORT
.It ip_tcp_port=LISTEN PORT
Port to listen on on udp or tcp. Udp  is also source port for outbound messages. Range is 1-65535, default value is 0 which means we don't listen.
If left unspecified, no listening takes place.
.It ip_input_types=ARRAY DEFINITION
Specification of expected data to receive from remote. See
.Xr rrr_post(1)
for the syntax. No listening takes places unless this is specified.
To receive RRR messages, simply set the definition to
.B msg
and set
.B ip_extract_rrr_messages
to
.B yes.
.It ip_extract_rrr_messages={yes|no}
Extract any RRR messages from the received data (if specified in ip_input_types) and save them in the buffer for other modules to pick up.
Causes any other data in the received arrays to be dropped.
If set to yes and no message field is specified in the array definition, an error will be produced.
Defaults to no.
.It ip_max_message_size
Maximum size of a message when reading. This should be set to prevent messages with missing delimeters to fill up memory.
A value of 0 means unlimited message size.
Defaults to 4096.
.It ip_default_topic=MQTT-TOPIC
An optional MQTT topic to set on the generated messages.
.It ip_sync_byte_by_byte={yes|no}
If array parsing fails according to definition, keep skipping one byte forward in the stream until a match is found.
Defaults to no, which means to only sync on boundaries of incoming messages.
.It ip_send_rrr_message={yes|no}
If set to yes, we will send complete RRR messages encoded for network. If set to no or left unset,
messages with arrays will have their array packed and sent, and messages with other data will simply have their
contents sent as is.
.It ip_preserve_order={yes|no}
Attempt to send messages in order according to their timestamp. The order is not in any way guaranteed, but upon error conditions,
like when a remote TCP host is unavailable, IP will store the messages to send in order. This will impact performance. Defaults is no.
.It ip_drop_on_error={yes|no}
When a TCP connection is refused or times out, drop messages. Defaults to no.
.It ip_persistent_connections
After a packet is sent, don't close the TCP connection causing it to be re-used. Defaults to no.
.It ip_send_timeout=SECONDS
If messages are not successfully sent within this time, drop them. Default is not timeout (same as 0).
.It ip_target_host=HOST
.It ip_target_port=PORT
.It ip_target_protocol=PROTOCOL
Default target host, port and protocol for messages from other modules which do not contain address information.
If left unset and we recevie messages which do not contain address information, the messages are dropped
and warning messages are produced. Protocol may be udp or tcp, defaults to udp.
.It ip_force_target={yes|no}
Use the specified target host and port even if messages contain other address information. Default is no.
.It ip_array_send_tags=tag1[,tag2[,...]]
Look for the defined tags in array messages from other modules, and send these concatenated together to remote.
If this option is specified and a received message is not an array or does not have all of the tags defined,
the message is dropped and an error message is produced.
If this option is left unspecified, all values from arrays are sent, and messages which are not arrays will have their raw data sent if any.
.El
.PP
.SS voltmonitor (SA)
Read voltage readings from a USB device. For every reading, an array message is generated with the timestamp of the measurement
and the measurement itself as an unsigned 64-bit integer with the tag
.B measurement.
.PP
.Bl -tag -width -indent
.It vm_calibration=FLOAT
Factor to calibrate the readings, defaults to 1.124.
.It vm_channel={1|2}
Which channel to use on two-channel devices.
.It vm_message_topic=TOPIC
MQTT topic to apply to generated messages.
.El
.PP
.SS averager (PA)
The averager module reads point measurements from it's senders and produces average measurments over a given timespan and
at a given rate. Other messages are simply passed through.
.PP
The averager module expects to find the tag
.B measurement
in array messages from it's senders. It will generate average measurements with the following values as unsigned 64-bit integers:

.Bl -tag -width -indent
.It average
The average of the measurements received in the timespan.
.It max
The maximum value of all the measurements received in the timespan.
.It min
The minimum value of all the measurements received in the timespan.
.It timestamp_from
The lowest timestamp of all the measurements received in the timespan.
.It timestamp_to
The highest timestamp of all the measurements received in the timespan.
.El
.PP
.Bl -tag -width -indent
.It avg_timespan=SECONDS
How long timespan to average over. Defaults to 15 seconds.
.It avg_interval=SECONDS
How often to produce average calculations. Defaults to 10 seconds.
.It avg_preserve_points={yes|no}
Preserve individual measurements and put them in output buffer. Defaults to no.
.It avg_discard_unknowns={yes|no}
Delete messages which are not point measurements and information messages. Defaults to no, which means to simply forward them.
.It avg_message_topic=TOPIC
MQTT topic to apply to generated messages and any forwarded point messages.
.El
.SS buffer (P)
The buffer collects all messages from all senders and wait for them to be collected by another instance.
.SS duplicator (P)
The duplicator works like buffer only that it creates one output buffer for every reader and duplicates the
data it reads from other modules for each reader. The readers of duplicator are detected automatically.
.SS ipclient (PI)
The ipclient module collects any messages from senders and sends them over the network to another 
.B RRR
environment's ipclient module using UDP. It may also accept connections from other clients and receive data,
or a combination of these. An underlying UDP stream protocol ensures single delivery of
all messages (similar design as MQTT QOS2), and messages are checksummed with a CRC32 algorithm.
.PP
.B ipclient is not secure in any way and must only be used on closed networks!
.PP
After an ipclient instance has connected to a remote ipclient, the remote will accept packets, and the connection
persists even if the connecting clients IP-address changes unless specified otherwise in the configuration.
.PP
Please note that ipclient is not designed to receive connections and packets from arbitary remote hosts.
If a remote sends packets and does not complete the acknowledgement handshakes, the packets will persist in memory.
.PP
If a remote host becomes unavailable for a longer period of time, unfinished acknowledgement handshakes
are re-initiated when it becomes available again, even if it has been re-started in the mean time.
.PP
ipclient will not accept incoming connections from other clients unless explicitly told to in the configuration file.
.PP
.Bl -tag -width -indent
.It ipclient_client_number=NUMBER
Each ipclient instance in a set of instances which communicate together must have a unique ID number in the range 1-4294967295.
If you have two instances running, set one of them to 1 and the other one to 2.
.It ipclient_default_remote=REMOTE NAME OR ADDRESS
The name or address of the client which we send packets without address information to.
.It ipclient_default_remote_port=PORT NUMBER
The port number of the default remote, defaults to 5555.
.It ipclient_src_port=PORT NUMBER
Source port used for sending and receiving packtes, defaults to 5555.
.It ipclient_listen={yes|no}
Accept incoming connections if set to yes. Default is no.
.It ipclient_disallow_remote_ip_swap={yes|no}
If yes and a remote changes its IP-address, RRR must restart before the new address can be accepted. Default is no. 
.El
.SS mysql (DAI)
This module will read in messages from other modules, possibly IP-capable, and save them to a myqsl or MariaDB 
database.
.PP
A column plan must be used to describe the table we are saving to. The received data must match this column plan. If
the data saving for any reason fails, like if the database is down or the table is misconfigured, we cache the failed messages
and try again later. It is not possible for the mysql module to know wether it's settings are at fault or if the database
is at fault. Messages which fails can regardless of this be set to be dropped instead upon errors.
.Bl -tag -width -indent
.It mysql_server=SERVER NAME
The server name of the MySQL or MariaDB server to use
.It mysql_port=PORT NUMBER
The port number used to connect to the server.
.It mysql_user=USER NAME
The username for logging into the server
.It mysql_password=PASSWORD
The password for logging into the server
.It mysql_db=DATABASE NAME
The name of the database to use
.It mysql_table=TABLE NAME
The table name to use for storing data
.It mysql_drop_unknown_messages={yes|no}
If a message fails to be saved into the specified table for any reason, simply delete it instead of trying again later. Defaults to no.
.It mysql_columns={column name 1,column name 2,...}
Specify the columns in the table to write data to. The column count must match the number of values received in array
messages from other modules. The data types only matters to some extent, the columns should be able to hold the data
types received. Integers are sent to the database as integers and blobs are sent as blobs.
If an array contains items with more than one value, one column should be specified for the whole item. These items are always sent
to mysql as blobs.
This option cannot be used with
.B mysql_column_tags.
.It mysql_column_tags=ARRAY TAG[->MYSQL COLUMN][,...]
A comma separated list of items to retrieve from the received array messages and to use as
columns in MySQL. If a tag name is specified on is own, the tag and the corresponding column in MySQL has the same name.
If the MySQL column name is different from the tag, an arrow followed by the MySQL column name is put after the tag name.
This option cannot be used with
.B mysql_colums.
.It mysql_blob_write_columns={column name 1,column name 2,...}
Used to force to send data as blob (raw data) to the database for the specified columns regardless of their type.
.It mysql_special_columns={column1=value1,column2=value2,...}
Used to write fixed values to the database.
.It mysql_add_timestamp_col={yes|no}
In addition to the other columns, write to a column named `timestamp` and save the timestamp from the message here.
.It mysql_strip_array_separators={yes|no}
Disregard any separator items in received array messages. Defaults to yes.
.El
.SS python3 (PAI)
This module can send messages to a custom python program and read them back.
All messages read from the senders are sent to the python program to the process function specified.
A read-only source function may also be specified if the python program should only generate messages by itself and not receive any.
It is possible to specify both source- and process-functions at the same time.
Functions should return 0 on success and put any messages into the result class provided in the argument.
If something goes wrong, the functions can return 1 or raise an exception which makes RRR stop all running instances and restart.
.PP
The RRR module should be imported by the custom python program, but is in only available when the python script is called from RRR.
.PP
The following options may be specified:
.Bl -tag -width -indent
.It python3_module=MODULE NAME
The module name for the python3 program to be executed. Imported by 'from MODULE NAME import *'
.It python3_module_path=MODULE NAME
An extra path in which to search for the module.
.It python3_source_function=FUNCTION NAME
The name of the source function in the python program which we read from continously.
.It python3_process_function=FUNCTION NAME
The name of the processing function in the python program which we send packets from other modules to. We also read any messages sent back.
.It python3_config_function=FUNCTION NAME
The name of the function in the python program to which we send settings form the configuration file.
All settings defined inside the python block in the configuration file are sent in here.
.It CUSTOM SETTING=VALUE
Any number of custom settings for the python program might be set as needed.
.El
.PP
Refer to the
.B cmodule
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of the following parameters:
.PP
.Bl -tag -width -indent
.It python3_source_interval_ms=MILLISECONDS
.It python3_sleep_time_ms=MILLISECONDS
.It python3_nothing_happend_limit=UNSIGNED INTEGER
.It python3_log_prefix=PREFIX
.It python3_drop_on_error={yes|no}
.El
.PP
Below follows an example python message processing and generating program. A socket is used to
post messages. The process and source functions have their own environments, and they will not
share any global variables set by the config function. The config function is called first in
the process environment, then in the source environment.
.PP
.nf
from rrr_helper import *
import time

my_global_variable = ""

def config(rrr_config : config):
	global my_global_variable

	# retrieve a custom setting from the configuration file. The get()
	# will update the "was-used" flag in the setting which stops a
	# warning from being printed.
	print ("Received configuration parameters")
	my_global_variable = config.get("my_global_variable")

	return True

def process(socket : rrr_socket, message: rrr_message):
	# Return False if something is wrong
	if my_global_variable == "":
		print("Error: configuration failure")
		return False
		
	# modify the retrieved message as needed
	message.timestamp = message.timestamp + 1
	
	# queue the message to be sent back (optional) for python to give to readers
	socket.send(message)
	
	return True

def source(socket : rrr_socket, message : rrr_message):
	# Set an array value in the template message
    my_array_value = rrr_array_value()
    my_array_value.set_tag("my_tag")
    my_array_value.set(0, "my_value")

    my_array = rrr_array()
    my_array.append(my_array_value)

    message.set_array(my_array)

	# queue the message to be sent back (optional) for python to give to readers
	# skip this step if the message are not to be sent, it is then simply discarded
	# may be called multiple times with the same message
	socket.send(message)
	
	# sleep to limit output rate
	time.sleep(1)

	return True
	
.fi
More details about Python in 
.Xr rrr_python3(5)
.PP
.SS perl5 (PAI)
The perl5 module makes it possible to process and generate messages in a custom 
perl script. The first and only argument to the source- and generate-functions
is the RRR message in the form of a hash with different parameters which may be
modified as needed. To pass the message back to RRR, the
.B send()-method
of the message must be called. If the message should not be passed on, simply skip
the call to this method. The method may be called multiple times if required.
.PP
It is possible to work with RRR array messages in the Perl script. This is done by
adding values to or removing values from three control arrays which are always defined
in a message hash. The number of elements in these arrays must always be equal, this is
strictly enforced. Each array item is this defined by having a value in each of the three
control arrays. An array value must be at the same position in each of the three arrays.
.PP
If the control arrays have no values, the message will not be treated as an array message in RRR.
.PP
The three control arrays in the message hash are:
.Bl -tag -width -indent
.It array_values
The actual data of each array value. If an array value has multiple data values, they must be put inside another array and a reference to this must be set in array_values.
.It array_tags
The tag of the array value. Set an empty string if no tag is to be set.
.It array_types
The type of the value in string form. Possible values are
.B str
(string value),
.B h
(integer value),
.B fixp
(fixed pointer value),
.B ustr
(unsigned number as string),
.B istr
(signed number as string),
.B nsep
(non-separator/whitespace characters),
.B sep
(a separator character),
.B blob
(binary data) and
.B msg
(complete encoded RRR message)
.El
More details about types are found in 
.Xr rrr_post(1)
.PP
.Bl -tag -width -indent
.It perl5_file=FILENAME
Path and filename of the perl script to use. The script is run once when the program starts,
which means that code may be added outside the three subroutines mentioned below.
.It perl5_source_interval=MILLISECONDS
How long to wait between each call of the source subroutine (if defined). Defaults to 1000 ms.
.It perl5_source_sub=SUBROUTINE NAME
Optional name of a subroutine which receives an rrr::rrr_helper::rrr_message object and modifies
it to generate a new message. Called at specified interval.
.It perl5_process_sub=SUBROUTINE NAME
Optional name of a subroutine which receives an rrr::rrr_helper::rrr_message object from the senders
of the current instance. The message may be modified or left alone.
.It perl5_config_sub=SUBROUTINE NAME
Optional name of a subroutine which receives an rrr::rrr_helper::rrr_settings object when the program
is started. Any settings from the instance definition in the configuration file can be read from
this object, also custom settings. Settings may also be modified and new settings can be added. The
settings object may also be stored in the script to be read from or modified from the source- and 
generate-subroutines.
.It CUSTOM SETTING=VALUE
Any number of custom settings for the Perl script might be set as needed.
.El
.PP
Refer to the
.B cmodule
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of the following parameters:
.PP
.Bl -tag -width -indent
.It perl5_source_interval_ms=MILLISECONDS
.It perl5_sleep_time_ms=MILLISECONDS
.It perl5_nothing_happend_limit=UNSIGNED INTEGER
.It perl5_log_prefix=PREFIX
.It perl5_drop_on_error={yes|no}
.El
.PP
.B NOTE:
Any modified settings will currently not be visible in the perl5 RRR module, only in the perl5 script.
.PP
There must always be either a source- or process subroutine specified, or both. If a process subroutine
is specified, there must also be at least one sender specified.
.PP
If a Perl instance receives messages from an IP-capable module, like
.B udp,
the address information of the original sender of a message is retained. Other IP-capable modules may
then use this information if they read data from the Perl instance, for example if you wish to use
a Perl script to generate a reply message to some remote host. There is no high-level method for modifying
the address information inside the Perl script, but the values
.B ip_addr
and
.B ip_addr_len
are to be found in the message hash. The values are filled with data from
.B struct sockaddr
and
.B socklen_t
which is provided by the operating system. These two values may be saved and re-used in later messages,
or they may be modified if you know how to do that (not documented here).
In addition,
.B ip_so_type
can be either "udp" or "tcp" to describe a protocol type. Some modules may use this parameter. It can also be empty.
.PP
The following additional parameters are available in the rrr_message hash reference:
.Bl -tag -width -indent
.It topic
The MQTT topic of the messsage.
.It timestamp
The timestamp of the message.
.It data
The raw data of the message (ignored when arrays are being used)
.It data_length
The length of the data.
.It type_and_class
Type and class of message, for internal use.
.El
.PP
The
.B rrr_debug
class can be used to print out debug messages just like RRR does internally. Use these instead of perl print functions
if you wish to have your program output messages in a tidy controlled fashion. There are three different functions in this class:
.PP
.Bl -tag -width -indent
.It msg(level, message)
Messages to this function are always printed prefixed with the specified loglevel (a number 0, 1, 2 etc.).
.It dbg(level, message)
Messages to this function are printed only if the specified loglevel (debuglevel) is active. If loglevel is 0 however,
the message is always printed.
.It err(message)
Messages to this function are always printed with loglevel 0 and to STDERR output. Do not overuse this as it might
cause broadcast messages on the system when RRR is run for instance by systemd. Error messages should usually be
printed using the
.B msg
function with loglevel 0.
.El
.PP
A variable must be blessed with the
.B rrr_debug
class to use the debug functions, look at the code below on how to do this. There are also commented out example
calls to message print functions. 
.PP
Below follows an example perl script.
.PP
.nf
#!/usr/bin/perl -w

package main;

use rrr::rrr_helper;
use rrr::rrr_helper::rrr_message;
use rrr::rrr_helper::rrr_settings;
use rrr::rrr_helper::rrr_debug;

my $debug = { };
bless $debug, rrr::rrr_helper::rrr_debug;

my $global_settings = undef;

sub config {
	# Get the rrr_settings-object. Has get(key) and set(key,value) methods.
	my $settings = shift;

	# If needed, save the settings object
	$global_settings = $settings;

	# Custom settings from the configuration file must be read to avoid warning messages
	# $debug->msg(1, "my_custom_setting is: " . $settings->get("my_custom_setting") . "\\n");

	# Set a custom setting
	$settings->set("my_new_setting", "5");

	# Return 1 for success and 0 for error
	return 1;
}

sub source {
	# Receive a newly generated template message
	my $message = shift;

	# Do some modifications
	$message->{'timestamp'} = $message->{'timestamp'} - $global_settings->get("my_custom_setting");

	# $debug->msg(1, "source:  new timestamp of message is: " . $message->{'timestamp'} . "\\n");

	# Pass on the new message
	$message->send();

	# Return 1 for success and 0 for error
	return 1;
}

sub process {
	# Get a message from senders of the perl5 instance
	my $message = shift;

	# Do some modifications to the message
	$message->{'timestamp'} = $message->{'timestamp'} - $global_settings->get("my_custom_setting");

	# $debug->msg(1, "process: new timestamp of message is: " . $message->{'timestamp'} . "\\n");

	# Push an array value to the message array
	push @{$message->{'array_values'}}, "My array string value";
	push @{$message->{'array_tags'}}, "tag_for_string_value";
	push @{$message->{'array_types'}}, "str";

	# Set some integer values
	my @my_integers = (1, 2, 3, 4);
	
	# Push the integer values into the message array. Remember the backslash to make a reference.
	push @{$message->{'array_values'}}, \\@my_integers;
	push @{$message->{'array_tags'}}, "tag_for_integer_value";
	push @{$message->{'array_types'}}, "h"; 

	# Pass on the modified message
	$message->send();

	# Return 1 for success and 0 for error
	return 1;
}
.fi
.SS cmodule (P)
This module allows usage of custom cmodules (C-modules) in a simplified framework. To use this, a module must first be
written in the RRR source in the directory /src/cmodules/ and then compiled (just compile RRR as usual and
directions will be given). There is an example file with appropriate licenses in the cmodules directory
which may be used as a template for custom cmodules.
.PP
RRR will deal with communication with other modules and many other tasks, which makes it simpler to write a
cmodule than to write a native RRR module.
.PP
All custom cmodules will be run in separate forks.
.PP
.Bl -tag -width -indent
.It cmodule_name=NAME
The name of the cmodule. If the name is
.B dummy,
RRR will look for the module
.B dummy.so
and the source file for this module should be called
.B dummy.c.
.It cmodule_config_function=NAME
The function to which to pass configuration parameters, called at program startup. Optional.
.It cmodule_source_function=NAME
The function to which to call to source new messages. Optional, but at least one of source and processor must be set.
.It cmodule_process_function=NAME
The function to which to call to process messages from senders. Optional, but at least one of source and processor must be set.
.It cmodule_cleanup_function=NAME
The function to call before the program shuts down. Optional.
.It CUSTOM SETTING=VALUE
Any number of custom settings for the C-module might be set as needed.
.El
.PP
Refer to the
.B cmodule
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of the following parameters:
.PP
.Bl -tag -width -indent
.It cmodule_source_interval_ms=MILLISECONDS
.It cmodule_sleep_time_ms=MILLISECONDS
.It cmodule_nothing_happend_limit=UNSIGNED INTEGER
.It cmodule_log_prefix=PREFIX
.It cmodule_drop_on_error={yes|no}
.El
.PP
The source and process functions receives a new message which of they must manage the memory. The message must
either be passed on to other modules by calling
.B rrr_send_and_free(...)
or be freed (if the message is to be discarded) by calling
.B rrr_free(...).
A message, if it must be sent several times, may be duplicated by using.
.B rrr_message_duplicate(...).
.PP
Please refer to the source code on how these functions work. Some headers which
might be useful when working with for instance array messages are included in /src/cmodules/cmodule.h .
It is not a priority at this time to document these, but they are easy to use and usage examples are to
be found throughout the RRR source code (which is human- and machine readable).
.PP
Functions must return 0 on success and 1 if there are errors.  
.SS raw (PAI)
This module simply drains data from it's senders and deletes it after printing a message if debugging is active. It
can read from both IP modules and non-IP.
.PP

.Bl -tag -width -indent
.It raw_print_data={yes|no}
Print the timestamp of each received message and dump any arrays present in the messages. The global debuglevel 2 must
be set for messages to actually be printed. This to avoid problems with the journal module.
.El
.SS socket (SA)
The socket module listens on a UNIX socket for RRR messages or custom data records.
.PP
.Bl -tag -width -indent
.It socket_path=FILENAME
Path and file name to use for the socket. The file cannot exist when the program starts.
.It socket_unlink_if_exists={yes|no}
If set to yes and the socket defined in `socket_path` exists when we start, unlink it. If set to no, we produce an error if
the socket exists. Defaults to no.
.It socket_default_topic=MQTT-TOPIC
An optional MQTT topic to set on the generated messages.
.It socket_receive_rrr_message={yes|no}
If set to 
.B yes
, complete RRR messages are expected to be received on the socket. No array definition is to be specified. 
.Xr rrr_post(1)
may generate such messages. If set to 
.B no
, an array definition must be specified, and RRR array messages will be produced from the received data. Defaults to no.
.It socket_input_types=ARRAY DEFINITION
Format of data received on the socket, see
.Xr rrr_post(1)
for syntax.
.It socket_sync_byte_by_byte={yes|no}
If array parsing fails according to definition, keep skipping one byte forward in the stream until a match is found.
Defaults to no, which means to only sync on boundaries of incoming messages.
.El
.SS httpserver (SAI)
This module accepts connections from HTTP clients, extracts POST or GET data fields and puts it into RRR array messages
for other modules to use. The query string from the URI is parsed in both GET and POST requests. Duplicate field names are allowed.
.PP
.B DO NOT USE
this HTTP server openly on the Internet. It has
.B NO PROTECTION MECHANISMS
against DoS attacks, flooding etc. There is also
.B NO AUTHENTICATION.
Use a server like Apache to run a public server.
.PP
This module does not respond with any data. If a request was successfully processed, a
.B 204 No Data
response is returned to the client. If there was any errors,
.B 400 Bad Request
or
.B 500 Internal Server Error
response may be returned.
.PP  
.Bl -tag -width -indent
.It http_server_transport_type={tls|plain|both}
Listen with TLS mode, plaintext mode or both. Defaults to 'plain'.
.It http_server_port_tls=PORT
Port to use for TLS listening, defaults to 443.
.It http_server_port_plain=PORT
Port to use for plaintext listening, defaults to 80.
.It http_server_fields_accept=HTTP FIELD[->ARRAY TAG][,...]
Specify a comma separated list POST and GET fields to allow from clients. Fields not specified here are ignored unless
.B http_server_fields_accept_any
is set to 'yes'.
An optional array tag may be specified for each field if the field name should be translated when added to the RRR array message. This parameter is optional.
.It http_server_fields_accept_any={yes|no}
Accept any field names from incoming requests. May not be used with
.B http_server_fields_accept_any. 
Defaults to 'no'.
.It http_server_allow_empty_messages={yes|no}
Create RRR messages for incoming request even if no field names would be added to the message. Defaults to 'no'.
.It http_server_tls_*
Refer to the
.B TLS
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of TLS parameters. All TLS parameters are optional.
.El
.PP
If none of
.B http_server_fields_accept_any, http_server_allow_empty_messages
and
.B http_server_fields_accept
are specified, no received requests will result into RRR messages being produced. 
.SS httpclient (DAI)
This module takes RRR messages from other modules and sends them to an HTTP server. Array values in received messages
may be sent as HTTP form fields. GET and POST are supported using either HTTP or HTTPS. This module does not
use any data sent from the server, any data received is ignored.
.PP
.Bl -tag -width -indent
.It http_server=SERVER OR IP
Server to send data to, defaults to 'localhost'.
.B httpclient
will follow any redirects from the server, also to other servers. Redirects may be disabled.  
.It http_endpoint=ENDPOINT
The endpoint to request from the server, e.g.
.B /index.php.
If the server responds with a redirect, this new endpoint will be used.
It is possible to specify a query string in the endpoint, like
.B /index.php?a=1&b=2.
If the server responds with redirect, this query string will not be included in the folling request.
If GET method is used, any query values from RRR messages will be appended to the query string, also if there are redirects.
.B httpclient
will detect whether a query string already exists in the URL and prefix the first parameter with either ? or &.
Defaults to
.B /.
.It http_transport_type={tls|plain|both}
If transport type is set to 'plain' or 'tls', HTTP or HTTPS will be
.B enforced,
which means that redirects fro the server to a different transport type than the chosen one will be rejected.
Use 'both' or leave unspecified for automatic transport type.
.It http_port=PORT
Port to use when connecting to the server. Defaults to 80 for HTTP and 443 for HTTPS. Redirects from the server to other
ports will override this value.
.It http_method={get|post_urlencoded|post_multipart}
Which method to use when sending data to the server. Defaults to
.B get.
.br
\(bu If
.B get
is used, any fields will be appended to the endpoint after a questionmark ?. GET requests have no body.
.br
\(bu If
.B post_urlencoded
is used, any fields will be made into a query string and sent in the POST body of type 'application/x-www-form-urlencoded'.
.br
\(bu If
.B post_multipart
is used, any fields will be made into separate mime parts and sent in the POST body of type 'multipart/form-data'. This method is recommended for large data fields. 
.It http_tags=ARRAY TAG[->HTTP FIELD NAME][,...]
A comma separated list of array tags to find in RRR messages from other modules.
If left unspecified, all array values found will be sent to the HTTP server.
If a tag is postfixed with a
.B HTTP FIELD NAME,
this name instead of the array tag name when sending data to the HTTP server.
If tags are specified and an RRR message from a sender is missing one or more of the specified tags, and error is produced. 
.It http_fields=HTTP FIELD NAME[=VALUE][,...]
A set of fixed fields to send to the HTTP server, optionally with values. Values from
.B http_fields
are always sent regardless of
.B http_tags.
.It http_rrr_msg_to_array={yes|no}
Convert fields in RRR messages from other modules to array values. The fields used are
.B timestamp, topic
and
.B data.
These values may be used in the same way as any other array values from the messages, they may also be matched in the
.B http_tags
parameter. If
.B http_tags
is specified, values from the RRR message will only be sent if they are specified here. Defaults to 'no'.
.It http_no_data={yes|no}
Ignore all data in RRR messages from other modules. Only query values in
.B http_endpoint
and
.B http_fields
, if specified, will be sent to the server. Defaults to 'no'.
.It http_drop_on_error={yes|no}
If there is any error while sending a message, drop it instead of deferring it and trying again later. Errors will be logged regardless of this setting. Defaults to 'no'.
.It http_message_timeout_ms=MILLISECONDS
Timeout for deferred messages, defaults to 0 which means no timeout.
.It http_max_redirects=UNSIGNED INTEGER
The maximum number of redirects to allow from the server for a single message. May be set to 0 to disallow redirects. Defaults to 5, maximum is 500.
.It http_tls_*
Refer to the
.B TLS
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of TLS parameters. All TLS parameters are optional.
.El
.SS influxdb (DA)
This module receives array messages from other modules and sends their data to an Influx database using HTTP.
.Bl -tag -width -indent
.It influxdb_server=HOSTNAME
The IP address or hostname of the host running an Influxdb database.
.It influxdb_database=DATABASE
The database name to use on the server.
.It influxdb_table=TABLE
The table in the database in which to store the data.
.It influxdb_port=PORT
The port to use when connecting to the server, defaults to 8086.
.It influxdb_transport_type={plain|tls}
The transport type to use when connecting to the server. Defaults to 'plain'.
.It influxdb_tls_*
Refer to the
.B TLS
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of TLS parameters. All TLS parameters are optional.
.It influxdb_tags=ARRAY TAG[->INFLUXDB TAG][,...]
A comma separated list of items to retrieve from the received array messages and which should be used as
.B tags
in InfluxDB. If the tag of an
item in an array is not equal to the tag in InfluxDB, the tag may be followed by
.B ->INFLUXDB TAG
to translate the tag name. 
Items in an array message which are not tagged cannot be used.
.It influxdb_fields=ARRAY TAG[->INFLUXDB FIELD][,...]
A comma separated list of items to retrieve from the array and which are to be used as
.B fields
in InfluxDB. Otherwise same rules as for tags.
.It influxdb_fixed_tags=TAG[=VALUE][,...]
Optional comma separated list of fixed tags (and optionally with values) to save to InfluxDB.
.It influxdb_fixed_fields=FIELD[=VALUE][,...]
Optional comma separated list of fixed fields (and optionally with values) to save to InfluxDB.
.El
It is required to have at least one tag specified in either
.B influxdb_fields
or
.B influxdb_fixed_fields
.
.SS mqttbroker (N)
An MQTT broker supporting V3.1(.1) and V5 (lacking some functionality).
.PP
.Bl -tag -width -indent
.It mqtt_broker_port=PORT
TCP port to listen on (listens on all interfaces). Defaults to 1883.
.It mqtt_broker_port_tls=PORT
TCP port to listen on for TLS connections (listens on all interfaces). Defaults to 8883.
.It mqtt_broker_transport_type={plain|tls|both}
The transport type to use when listening. Defaults to 'plain'.
.It mqtt_broker_tls_*
Refer to the
.B TLS
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of TLS parameters. All TLS parameters are optional except from certificate file and private key.
.It mqtt_broker_max_keep_alive=SECONDS
Maximum keep-alive value for clients, defaults to 30.
.It mqtt_broker_retry_interval=SECONDS
Retry interval for QoS1 and QoS2 messages.
.It mqtt_broker_close_wait_time=SECONDS
After disconnect, wait this many seconds before closing the socket (make client close first to avoid TIME_WAIT). Defaults to 1 second.
.It mqtt_broker_v31_disconnect_on_publish_deny={yes|no}
If a V3.1 or V3.1.1 client sends a PUBLISH which is rejected by ACL rules, the client will be disconnected
if this option is set to yes. The default value is no, which means that the broker sends an acknowledgement packet
regardless of whether the PUBLISH was rejected or not. For V5, an acknowledgement with an error code is always sent,
disregarding this option.
.It mqtt_broker_password_file=FILENAME
Filename of an RRR password file created by
.Xr rrr_passwd(1)
with which users are authenticated. If left unspecified, all CONNECT packets containing a username will be rejected.
RRR does not allow CONNECT packets only containing usernames, a password must always be set.
.It mqtt_broker_permission_name=PERMISSION
The permission name to which a user must have been registered with by using
.Xr rrr_passwd(1)
to become authenticated with this broker. Defaults to
.B mqtt. 
.It mqtt_broker_require_authentication={yes|no}
Disallow anonymous logins. This defaults to 'yes' if a password file is set, otherwise it defaults to 'no'.
.It mqtt_broker_acl_file=FILENAME
ACL file to allow different users access to topics. If left unspecified, all access is granted. If a file is specified and a rule
is not found upon a PUBLISH or SUBSCRIBE from a client, access will be denied.
.PP
The ACL file consists of one or more
.B TOPIC {TOPIC STRING}
blocks. The
.B TOPIC STRING
value is an MQTT filter in which # and + are allowed according to the MQTT specifications. Curly brackets are not to be included.
.PP
A topic block may contain one or more lines beginning with one of the keywords
.B USER
or
.B DEFAULT
followed by one or more spaces or tabs. Keywords are case-insensitive.
.PP
The
.B DEFAULT
keyword takes one argument, an ACL action (DENY, READ or WRITE). If left unspecified, the default action is DENY.
.PP
The
.B USER
keyword takes two arguments, a username followed by one or more spaces or tabs and an ACL action (DENY, READ or WRITE).
.El
.PP
If
.B READ
access is granted, a user may SUBSCRIBE to the matching topics. If
.B WRITE
access is granted, a user may SUBSCRIBE and PUBLISH to the matching topics.
.B DENY
will block all access to the matching topics. 
.PP
The ACL file is parsed from top to bottom, and the bottom most matching rule will take precedence.
.PP
Comments may be placed on separate lines and begins with '#'. Spaces and tabs are allowed on the beginning of a line before keywords.
.PP
Below follows some example rules:
.PP
.nf
# BEGIN ACL FILE
# Allow access to everything from everyone
TOPIC #
	DEFAULT WRITE

# Allow only READ access on $SYS topics, but allow system_user to WRITE
TOPIC $SYS/#
	DEFAULT READ
	USER system_user WRITE
# END ACL FILE
.fi
.PP
The MQTT server follows the specifications from Oasis, but lacks support for the following (will be implemented shortly):
.PP
\(bu Retained topics
.br
\(bu Will topics
.br
\(bu Authorization (simple username/password implemented)
.PP
.SS mqttclient (PA)
An MQTT client supporting V3.1.1 and V5. The client will publish RRR messages it receives from other modules, and
other modules can read messages the client receives on subscribed topics.
.PP
.Bl -tag -width -indent
.It mqtt_server=HOST
Host name or IP of the broker to connect to. Defaults to localhost.
.It mqtt_server_port=PORT
TCP port on the server for TLS connections, defaults to 1883 for plain transport and 8883 for TLS connection.
.It mqtt_transport_type={plain|tls}
The transport type to use when connecting to the server. Defaults to 'plain'.
.It mqtt_tls_*
Refer to the
.B TLS
part of the
.B COMMON CONFIGURATION PARAMETERS
section for descriptions of TLS parameters. All TLS parameters are optional.
.It mqtt_client_identifier=IDENTIFIER
Client identifier to use. If left unspecified, the broker picks one.
.It mqtt_v5_recycle_assigned_client_identifier={yes|no}
If we let the broker pick a client identifier and we are using protocol version 5, the broker will inform the client
about which client identifier it assigned. If this option is set to yes and the client needs to re-connect for some reason,
it will attempt to use this assigned client identifier. In version 3, the broker does not inform the client about the
picked client identifier and this option is then ignored. Defaults to 'yes'.
.It mqtt_connect_error_action={restart|retry}
Default action if connecting to the server failed. If set to
.B restart,
all RRR modules will be restarted after a few connection attempts (might cause messages to be lost). If set to
.B retry,
the client will keep trying to connect without any restart (messages will not be lost). Default action is to restart.
.It mqtt_connect_attempts=NUMBER OF ATTEMPTS
How many times we attempt connecting to the broker before giving up.
What we do when this number is reached depends on the setting
.B mqtt_connect_error_action.
One connection attempt lasts approximately 100ms. Must be 1 or more, defaults to 20.
.It mqtt_discard_on_connect_retry={yes|no}
With this option set to 'yes' while
.B mqtt_connect_error_action
is 'retry' and a connect retry is performed, queued messages will be read from all senders and discarded. This might be needed
to avoid non-processed messages filling up memory in situations where the broker is not available for a longer period. If however
.B  mqtt_connect_error_action
is 'restart', all messages will be cleared anyway when all instances restart after mqttclient fails to connect.
.B mqtt_discard_on_connect_retry
may not be set to 'yes' in this situation. Defaults to 'no'.  
.It mqtt_username=USERNAME
.It mqtt_password=PASSWORD
Optional username and password to send in CONNECT packets. If a password is set, a username
.B must
also be set. Note that the RRR MQTT broker disallows connects with username only, other brokers might handle this differently.
.It mqtt_qos={0|1|2}
Default Quality of Service to use, defaults to 1.
.It mqtt_version={3.1.1|5}
Default MQTT protocol version to use, defaults to 3.1.1.
.It mqtt_publish_topic=TOPIC
Topic to use when publishing RRR messages without topic set in them.
If left unspecified, RRR messages without a topic will be dropped.
.It mqtt_publish_topic_force={yes|no}
Force use of the topic specified in
.B mqtt_publish_topic
and disregard any topic in RRR messages. Cannot be used with
.B mqtt_publish_topic_prepend.
Defaults to no.
.It mqtt_publish_topic_prepend={yes|no}
The topic specified in
.B mqtt_publish_topic
is prepended to the topic RRR messages. No trailing or leading slashes are added. Cannot be used with
.B mqtt_publish_topic_force.
Messages without a topic are dropped if set to yes. Defaults to no.
.It mqtt_publish_rrr_message={yes|no}
If set to yes, the client will send full RRR messages.
If set to no, the raw data field of each RRR message will be sent, or a descriptive string with the message
type, class and timestamp is put into the publish payload for messages which do not have any data. Defaults to yes.
.It mqtt_publish_array_values={*|tag1[,tag2[,...]]}
Put all values from an array (*) or selected values (by tag) into the payload of PUBLISH messages. RRR
messages which does not contain an array are dropped. Any integer types will have big endianess in the resulting publish message.
Cannot be used with
.B mqtt_publish_rrr_message=yes.
.It mqtt_subscribe_topics=TOPIC1[,TOPIC2[,...]]
MQTT topic patterns to subscribe to (if any).
.It mqtt_receive_rrr_message={yes|no}
Expect to receive RRR messages from the broker.
If set to yes, any messages received which are not RRR messages are dropped.
If set to no and protocol version is V3.1.1, any data in messages received are put into a new RRR message.
If set to no and protocol version is V5, type of the received message is auto-detected.
Defaults to no.
.It mqtt_receive_array=ARRAY DEFINITION
If set, expect to receive data arrays of specific formats in publish messages.
This option cannot be used with mqtt_receive_rrr_message=yes, however if protocol version is V5,
received RRR messages will still be auto-detected, and array parsing will not occur for these.
Multiple data array records may reside in a single PUBLISH message, one RRR message will be generated for each record. 
Refer to
.Xr rrr_post(1)
for syntax of array definitions.
.El
.SS journal (SA)
Picks up RRR journal log messages and places them into arrays for other modules to read. Please note that this is not possible
to do with certain debuglevels active as passing messages generated by
.B journal
would cause generation of even more messages at an exponential growth rate.
.PP
RRR log messages from
.B journal
will have their MQTT topic set to
.B rrr/journal/{log_prefix}
where {log_prefix} (without curly brackets) is set by the originating module. It is not possible to change this topic,
but it may be changed in other modules which use these messages if required. See more details further down.
.PP
If a global debuglevel other than 1 is active, ...
.PP
\(bu all messages with a loglevel other 1 will be suppressed.
.br
\(bu messages from custom scripts which generate log messages (regardless of debuglevel) on other loglevels than 1 will be suppressed.
.br  
\(bu all log messages are still delivered to
.Xr rrr_stats(1)
and printed out (and delivered to syslog if RRR is an systemd daemon).
.PP
The following array tags can be retrieved from messages generated by
.B journal:
.PP
.Bl -tag -width -indent
.It log_level_translated
RFC 5424 loglevel, small integer.
.It log_prefix
The log prefix, usually path to the current RRR configuration file. 
.It log_message
The actual log message (including syslog-syntax for loglevel and prefix)
.It log_hostname
The hostname of the current host or overridden hostname from configuration file.
.El
.PP
Messages generated while RRR is processing a signal are not delivered to
.B journal.
.PP
The following configuration parameters are available:
.PP
.Bl -tag -width -indent
.It journal_generate_test_messages={yes|no}
Generate dummy messages for testing purposes. Defaults to no.
.It journal_hostname=HOSTNAME
Hostname to send along with log messages. Defaults to system hostname.
.El
.SH COMMON CONFIGURATION PARAMETERS
Replace the
.B X
with the configuration paramenter prefix of the module.
.PP
.SS cmodule parameters
.Bl -tag -width -indent
.It X_source_interval_ms=MILLISECONDS
How many milliseconds to wait between each call of the source function. Defaults to 1000, one second.
.It X_sleep_time_ms=MILLISECONDS
How many milliseconds to sleep if nothing was processed in the worker after multiple processing loops.
Sleeping is performed to limit CPU usage.
It is possible to specify 0 which in practice creates a very small wait.
The worker will sleep once every round until something happens again. Defaults to 50ms.
.It X_nothing_happend_limit=UNSIGNED INTEGER
How many loops to perform in the worker with nothing being processed before starting to sleep.
Defaults to 250, must be 1 or greater. 
.It X_log_prefix=PREFIX
Set a custom log prefix to be prepended to any log messages printed out. Use the RRR_MSG_x and RRR_DBG_x (x is a number)
macros to print messages like the reset of RRR does.
.It X_drop_on_error={yes|no}
If there is an error during processing of a message, just drop it instead of restarting the program.
Defaults to no.
.El
.SS TLS parameters
.Bl -tag -width -indent
.It X_tls_certificate_file=FILENAME
The certificate to use for TLS connections. Optional for clients, required for servers.
.It X_tls_key_file=FILENAME
The private key to use for TLS connections. Optional for clients, required for servers.
.It X_tls_ca_path=PATH[:OTHER_PATH...]
An alternative directory in which to search for CA certificates used when validating certificates. Debuglevel 1 will expose the actual search path. Optional.
.It X_tls_ca_file=FILENAME
A CA certificate file to use when validating certificates. Optional.
.El
.SH SEE ALSO
.Xr rrr(1),
.Xr rrr_post(1),
.Xr rrr_stats(1),
.Xr rrr_python3(5)
