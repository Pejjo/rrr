.Dd 2020-04-07
.TH RRR.CONF 5
.SH NAME
Read Route Record is a dynamic module-based message handling program
for collecting, buffering, processing and storing messages and measurements.
.SH DESCRIPTION
The
.B rrr
environment is set up with a configuration file. The file specifies any number
of
.B instances
of different
.B modules.
The different instances either get messages from other
modules or read them externally. Some also save messages externally or
send them over the network.
.PP
Instances are linked to each other using the 
.B senders=sender1,sender2,...
argument, which tells the instance which other modules to get messages from. A
.B source
module is a module which cannot read from other modules, and this argument should
not be specified.
.PP
.B rrr
may be extended with custom modules. Custom functionality may also be achieved by
using a module which can send data to and from a python program.
.PP
.B rrr
automatically restarts all running instances in case one instance for any
reason stops or hangs, like due to network problems. A failing instance
usually does not make
.B rrr
quit, all instances are simply restarted.
.PP
.SH SYNTAX
Any number of instances may be specified. An instance specification begins with a [] containing
the user chosen name of the instance. A module to use must then be specified, along with
module-specific settings. The
.B senders=
setting is mandatory for modules which read from other modules, but invalid for modules
which are sources (see MODULES section). An instance section ends when a new begins
or when we reach the end of the file.
.PP
.nf
# Comment begins with #, the rest of the line is ignored
[INSTANCE NAME]             # User chosen name of the instance
module={MODULE NAME}        # Which module to use for the instance
senders=INSTANCE NAME,...   # Which other instances to read from (not for source modules)
argument1=value1            # Module-specific arguments
argument2=value2
...
.BR
[INSTANCE NAME]
module={MODULE NAME}
...
.fi	
.PP
If an instance is specified as sender in more than one other instance, these will compete
about messages from it. Instances may not use themselves as senders.
.SH MESSAGES
A message consists of at least a timestamp (in milliseconds) which is used to identify the message. 
It may also contain one of the following types of data:
.SS VOLTAGE MESSAGES
The voltage message are an implementation used to get voltage readings (or other readings) with
max, min and average values and save them to a database. In the future, this
should be generalized.
.SS DATA ARRAY MESSAGES
Some modules support parsing data arrays from externally or from other modules. They might require a
list of expected data types to be specified in their configuration. If the total size of the input
does not match the received input, parsing of the message will fail.
.PP
The general syntax is a comma separated list of types with length and item count specifications. 
.PP
.DlÂ type1[length1][@count1][#tag1][,type2[length2][@count2][#tag2]][,...]
.PP
Refer to the
.B ARRAY DEFINITION
section of
.Xr rrr_post(1)
for the complete specification of all the types.
.SS IP MESSAGES
Some modules support parsing of IP messages. These are simply normal messages apart from that they also contain information
about the originating IP addresses. They are used for instance when sending replies back to a sender over network to know
where to send them. Some modules require that readers are IP capable when reading from them and vice versa.
.SS ACK MESSAGES
An ACK message is sent over network to inform senders that a packet was successfully received.
.SH MODULES
.PP
Modules have different special capabilites, denoted by the following letters. The actual implementation may
vary between modules. Many modules can despite this handle all types of messages, more or less ignoring their contents.
.PP
.Bl -tag -width -indent
.It S
Source module, cannot have senders
.It P
Processor modules, can have senders specified to read from (set with
.B senders=
)
.It D
Dead-end module, cannot be used as sender
.It N
Network-oriented module, cannot be used as sender nor have senders specified itself.
.It A
Module supports data arrays (see above)
.It I
Module supports IP messages
.It V
Module supports voltage reading messages
.El
If neither
.B A
nor
.B V
.PP
is specified for a module, it doesn't care about the contents of messages but simply forwards them. 
.PP
The following modules and module-specific arguments are available and can be used
.PP
.SS dummy (S)
Constantly generates empty messages only with a timestamp set.
.PP
.Bl -tag -width -indent
.It dummy_no_generation={yes|no}
No messages are generated, defaults to yes. 
.It dummy_no_sleeping={yes|no}
Don't sleep between creating messages, but create as many messages as the reader can handle. Defaults to no.
.It dummy_max_generated={unsigned number}
Stop generating messages after this number is reached. 0 value or not defined means that generation will not stop.
.El
.SS udp (PAI)
This module is capable of listening on an UDP port and read messages or arrays, as well as sending data to remote hosts.
A message is created for each received packet and a timestamp is added.
If the received data does not match the specified data array, the packet is dropped.
.PP
.PP
.Bl -tag -width -indent
.It udp_port=LISTEN PORT
Port to listen on and also source port for outbound messages, range is 1-65535.
If left unspecified, no listening takes place.
.It udp_input_types=ARRAY DEFINITION
Specification of expected data to receive from remote. See
.Xr rrr_post(1)
for the syntax. No listening takes places unless this is specified.
To receive RRR messages, simply set the definition to
.B msg
and set
.B udp_extract_rrr_messages
to
.B yes.
.It udp_extract_rrr_messages={yes|no}
Extract any RRR messages from the received data (if specified in udp_input_types) and save them in the buffer for other modules to pick up.
Causes any other data in the received arrays to be dropped.
If set to yes and no message field is specified in the array definition, an error will be produced.
Defaults to no.
.It udp_default_topic=MQTT-TOPIC
An optional MQTT topic to set on the generated messages.
.It udp_sync_byte_by_byte={yes|no}
If array parsing fails according to definition, keep skipping one byte forward in the stream until a match is found.
Defaults to no, which means to only sync on boundaries of incoming messages.
.It udp_send_rrr_message={yes|no}
If set to yes, UDP will send complete RRR messages encoded for network. If set to no or left unset,
messages with arrays will have their array packed and sent, and messages with other data will simply have their
contents sent as is.
.It udp_target_host=HOST
.It udp_target_port=PORT
Default target host and port for messages from other modules which do not contain address information.
If left unset and UDP recevies messages which do not contain address information, the messages are dropped
and warning messages are produced.
.It udp_force_target={yes|no}
Use the specified target host and port even if messages contain other address information. Default is no.
.It udp_array_send_tags=tag1[,tag2[,...]]
Look for the defined tags in array messages from other modules, and send these concatenated together to remote.
If this option is specified and a received message is not an array or does not have all of the tags defined,
the message is dropped and an error message is produced.
If this option is left unspecified, all values from arrays are sent, and messages which are not arrays will have their raw data sent if any. 
.El
.PP
.SS voltmonitor (SV)
Read voltage readings from a USB device.
.PP
.Bl -tag -width -indent
.It vm_calibration=FLOAT
Factor to calibrate the readings, defaults to 1.124.
.It vm_channel={1|2}
Which channel to use on two-channel devices.
.El
.PP
.SS averager (PV)
The averager reads point measurements from it's senders and produces average measurments over a given timespan and
at a given rate. Information messages are passed through, these might for instance contain status messages from
measurement devices.
.PP
.Bl -tag -width -indent
.It avg_timespan=SECONDS
How long timespan to average over. Defaults to 15 seconds.
.It avg_interval=SECONDS
How often to produce average calculations. Defaults to 10 seconds.
.It avg_preserve_points={yes|no}
Preserve individual measurements and put them in output buffer. Defaults to no.
.It avg_discard_unknowns={yes|no}
Delete messages which are not point measurements and information messages. Defaults to no, which means to simply forward them.
.El
.SS buffer (P)
The buffer collects all messages from all senders and wait for them to be collected by another instance.
.SS duplicator (P)
The duplicator works like buffer only that it creates one output buffer for every reader and duplicates the
data it reads from other modules for each reader. The readers of duplicator are detected automatically.
.SS ipclient (PI)
The ipclient module collects any messages from senders and sends them over the network to another 
.B RRR
environment's ipclient module using UDP. It may also accept connections from other clients and receive data,
or a combination of these. An underlying UDP stream protocol ensures single delivery of
all messages (similar design as MQTT QOS2), and messages are checksummed with a CRC32 algorithm.
.PP
.B ipclient is not secure in any way and must only be used on closed networks!
.PP
After an ipclient instance has connected to a remote ipclient, the remote will accept packets, and the connection
persists even if the connecting clients IP-address changes unless specified otherwise in the configuration.
.PP
Please not that ipclient is not designed to receive connections and packets from arbitary remote hosts.
If a remote sends packets and does not complete the acknowledgement handshakes, the packets will persist in memory.
.PP
If a remote host becomes unavailable for a longer period of time, unfinished acknowledgement handshakes
are re-initiated when it becomes available again, even if it has been re-started in the mean time.
.PP
ipclient will not accept incoming connections from other clients unless explicitly told to in the configuration file.
.PP
.Bl -tag -width -indent
.It ipclient_client_number=NUMBER
Each ipclient instance in a set of instances which communicate together must have a unique ID number in the range 1-4294967295.
If you have two instances running, set one of them to 1 and the other one to 2.
.It ipclient_default_remote=REMOTE NAME OR ADDRESS
The name or address of the client which we send packets without address information to.
.It ipclient_default_remote_port=PORT NUMBER
The port number of the default remote, defaults to 5555.
.It ipclient_src_port=PORT NUMBER
Source port used for sending and receiving packtes, defaults to 5555.
.It ipclient_listen={yes|no}
Accept incoming connections if set to yes. Default is no.
.It ipclient_disallow_remote_ip_swap={yes|no}
If yes and a remote changes its IP-address, RRR must restart before the new address can be accepted. Default is no. 
.El
.SS mysql (DAIV)
This module will read in messages from other modules, possibly IP-capable, and save them to a myqsl or MariaDB 
database. Tag messages are
generated for each saved message. Tag messages for messages originating locally (from non-IP modules) can only be picked
up by non-IP modules and vice versa.
.PP
A column plan must be used to describe the table we are saving to. The received data must match this column plan. If
data save for any reason fails, like if the database is down or the table is misconfigured, we cache the failed messages
and try again later. It is not possible for the mysql module to know wether it's settings are at fault or if the database
is at fault. Messages which fails can however be set to be dropped instead.
.Bl -tag -width -indent
.It mysql_server=SERVER NAME
The server name of the MySQL or MariaDB server to use
.It mysql_port=PORT NUMBER
The port number used to connect to the server.
.It mysql_user=USER NAME
The username for logging into the server
.It mysql_password=PASSWORD
The password for logging into the server
.It mysql_db=DATABASE NAME
The name of the database to use
.It mysql_table=TABLE NAME
The table name to use for storing data
.It mysql_drop_unknown_messages={yes|no}
If a message fails to be saved into the specified table for any reason, simply delete it instead of trying again later. Defaults to no.
.It mysql_colplan={array|voltage}
Specifiy wether a table with arbitary columns should be used, or a fixed voltage-style table.
.B timestamp
.  
.El
.PP
If the
.B voltage
column plan is used, we expect to receive voltage messages and the target table must contain at least these columns:
.PP
.nf
CREATE TABLE `entries` (
	`timestamp` bigint(20) UNSIGNED NOT NULL,
	`source` varchar(50) NOT NULL,
	`class` tinyint(3) UNSIGNED NOT NULL,
	`time_from` bigint(20) UNSIGNED NOT NULL,
	`time_to` bigint(20) UNSIGNED NOT NULL,
	`value` bigint(20) NOT NULL,
	`message` varchar(255) NOT NULL,
	`message_length` int(10) UNSIGNED NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=latin1;
.fi
.PP
If the
.B array
column plan is used, the following options can be used to describe the target table:
.PP
.Bl -tag -width -indent
.It mysql_columns={column name 1,column name 2,...}
Specify the columns in the table to write data to. The column count must match the number of values received in array
messages from other modules. The data types only matters to some extent, the columns should be able to hold the data
types received. Integers are sent to the database as integers and blobs are sent as blobs.
If an array contains items with more than one value, one column should be specified for the whole item. These items are always sent
to mysql as blobs.
This option cannot be used with
.B mysql_column_tags.
.It mysql_column_tags=ARRAY TAG[->MYSQL COLUMN][,...]
A comma separated list of items to retrieve from the received array messages and to use as
columns in MySQL. If a tag name is specified on is own, the tag and the corresponding column in MySQL has the same name.
If the MySQL column name is different from the tag, an arrow followed by the MySQL column name is put after the tag name.
This option cannot be used with
.B mysql_colums.
.It mysql_blob_write_columns={column name 1,column name 2,...}
Used to force to send data as blob (raw data) to the database for the specified columns regardless of their type.
.It mysql_special_columns={column1=value1,column2=value2,...}
Used to write fixed values to the database.
.It mysql_add_timestamp_col={yes|no}
In addition to the other columns, write to a column named `timestamp` and save the timestamp from the message here.
.It mysql_strip_array_separators={yes|no}
Disregard any separator items in received array messages. Defaults to yes.
.El
.SS python3 (P)
This module can send messages to a custom python program and read them back.
All messages read from the senders are sent to the python program to the process function specified.
A read-only source function may also be specified if the python program should only generate messages by itself and not receive any.
It is possible to specify both source- and process-functions at the same time.
Functions should return 0 on success and put any messages into the result class provided in the argument.
If something goes wrong, the functions can return 1 or raise an exception which makes RRR stop all running instances and restart.
.PP
The RRR module should be imported by the custom python program, but is in only available when the python script is called from RRR.
.PP
The following options may be specified:
.Bl -tag -width -indent
.It python3_module=MODULE NAME
The module name for the python3 program to be executed. Imported by 'from MODULE NAME import *'
.It python3_module_path=MODULE NAME
An extra path in which to search for the module.
.It python3_source_function=FUNCTION NAME
The name of the source function in the python program which we read from continously.
.It python3_process_function=FUNCTION NAME
The name of the processing function in the python program which we send packets from other modules to. We also read any messages sent back.
.It python3_config_function=FUNCTION NAME
The name of the function in the python program to which we send settings form the configuration file.
All settings defined inside the python block in the configuration file are sent in here.
The function might also notify that settings have been accessed to avoid warnings.
The config function is called once for every setting.
.It CUSTOM SETTING=VALUE
Any number of custom settings for the python program might be set as needed.
.El
.PP
Below follows an example python message processing and generating program. A socket is used to
post messages. The process and source functions have their own environments, and they will not
share any global variables set by the config function. The config function is called first in
the process environment, then in the source environment.
.PP
.nf
from rrr_helper import *
import time

my_global_variable = ""

def config(socket : rrr_socket, rrr_setting : setting):
	global my_global_variable

	# retrieve some custom settings from configuration file. The get()
	# will update the "was-used" flag in the setting.
	print ("Received a setting: " + setting.name + "=" + setting.get())

	# set a global variable
	if setting.name == "my_setting":
		my_global_variable = setting.get()

	# send settings back to update which have been read (optional)
	socket.send(setting)
	
	return True

def process(socket : rrr_socket, message: rrr_message):
	# Return False if something is wrong
	if my_global_variable == "":
		print("Error: configuration failure")
		return False
		
	# modify the retrieved message as needed
	message.timestamp_from = message.timestamp_from + 1
	
	# queue the message to be sent back (optional) for python to give to readers
	socket.send(message)
	
	return True

def source(socket : rrr_socket):
	# create a new message
	message = rrr_message(1, 2, 3, 4, 5, 6, bytearray("abcdefg", encoding='utf8'))
	
	# queue the message to be sent back (optional) for python to give to readers
	socket.send(message)
	
	# sleep to limit output rate
	time.sleep(1)

	return True
	
.fi
More details about Python in 
.Xr rrr_python3(5)
.PP
.SS perl5 (P)
The perl5 module makes it possible to process and generate messages in a custom 
perl script. The first and only argument to the source- and generate-functions
is always a message. Modifications to the message in the script will be done to the
original message, hence there is no need to return the message. A message can however
be duplicated one or more times by calling it's send()-method.
.PP
.Bl -tag -width -indent
.It perl5_file=FILENAME
Path and filename of the perl script to use. The script is run once when the program starts,
which means that code may be added outside the three subroutines mentioned below.
.It perl5_source_sub=SUBROUTINE NAME
Optional name of a subroutine which receives an rrr::rrr_helper::rrr_message object and modifies
it to generate a new message. Called continiously.
.It perl5_process_sub=SUBROUTINE NAME
Optional name of a subroutine which receives an rrr::rrr_helper::rrr_message object from the senders
of the current instance. The message may be modified or left alone.
.It perl5_config_sub=SUBROUTINE NAME
Optional name of a subroutine which receives an rrr::rrr_helper::rrr_settings object when the program
is started. Any settings from the instance definition in the configuration file can be read from
this object, also custom settings. Settings may also be modified and new settings can be added. The
settings object may also be stored in the script to be read from or modified from the source- and 
generate-subroutines.
.El
.PP
There must always be either a source- or process subroutine specified, or both. If a process subroutine
is specified, there must also be at least one sender specified.
.PP
Below follows an example perl script.
.PP
.nf
#!/usr/bin/perl -w

package main;

use rrr::rrr_helper;
use rrr::rrr_helper::rrr_message;
use rrr::rrr_helper::rrr_settings;

my $global_settings = undef;

sub config {
	# Get the rrr_settings-object. Has get(key) and set(key,value) methods.
	my $settings = shift;

	# If needed, save the settings object
	$global_settings = $settings;

	# Custom settings from the configuration file must be read to avoid warning messages
	# print "my_custom_setting is: " . $settings->get("my_custom_setting") . "\\n";

	# Set a custom setting
	$settings->set("my_new_setting", "5");

	return 1;
}

sub source {
	# Receive a newly generated template message
	my $message = shift;

	# Do some modifications
	$message->{'timestamp_from'} = $message->{'timestamp_from'} - $global_settings->get("my_custom_setting");

	# print "source:  new timestamp of message is: " . $message->{'timestamp_from'} . "\\n";

	# Sleep to ratelimit
	sleep 1;

	# Return 1 for success and 0 for error
	return 1;
}

sub process {
	# Get a message from senders of the perl5 instance
	my $message = shift;

	# Do some modifications to the message
	$message->{'timestamp_from'} = $message->{'timestamp_from'} - $global_settings->get("my_custom_setting");

	# print "process: new timestamp of message is: " . $message->{'timestamp_from'} . "\\n";

	# This can be used to duplicate a message, no need if we are not duplicating
	# $message->send();

	# Return 1 for success and 0 for error
	return 1;
}
.fi
.SS raw (P)
This module simply drains data from it's senders and deletes it after printing a message if debugging is active. It
can read from both IP modules and non-IP.
.PP

.Bl -tag -width -indent
.It raw_print_data={yes|no}
Print the timestamp of each received message.
.El
.SS socket (SA)
The socket module listens on a UNIX socket for RRR messages or custom data records.
.PP
.Bl -tag -width -indent
.It socket_path=FILENAME
Path and file name to use for the socket. The file cannot exist when the program starts. 
.It socket_default_topic=MQTT-TOPIC
An optional MQTT topic to set on the generated messages.
.It socket_receive_rrr_message={yes|no}
If set to 
.B yes
, complete RRR messages are expected to be received on the socket. No array definition is to be specified. 
.Xr rrr_post(1)
may generate such messages. If set to 
.B no
, an array definition must be specified, and RRR array messages will be produced from the received data. Defaults to no.
.It socket_input_types=ARRAY DEFINITION
Format of data received on the socket, see
.Xr rrr_post(1)
for syntax.
.It socket_sync_byte_by_byte={yes|no}
If array parsing fails according to definition, keep skipping one byte forward in the stream until a match is found.
Defaults to no, which means to only sync on boundaries of incoming messages.
.El
.SS influxdb (DA)
This module receives array messages from other modules and sends their data to an Influx database using HTTP.
 
.Bl -tag -width -indent
.It influxdb_server=HOSTNAME
The IP address or hostname of the host running an Influxdb database.
.It influxdb_database=DATABASE
The database name to use on the server.
.It influxdb_table=TABLE
The table in the database in which to store the data.
.It influxdb_port=PORT
An optional port to connect to on the server, defaults to 8086.
.It influxdb_tags=ARRAY TAG[->INFLUXDB TAG][,...]
A comma separated list of items to retrieve from the received array messages and which should be used as
.B tags
in InfluxDB. If the tag of an
item in an array is not equal to the tag in InfluxDB, the tag may be followed by
.B ->INFLUXDB TAG
to translate the tag name. 
Items in an array message which are not tagged cannot be used.
.It influxdb_fields=ARRAY TAG[->INFLUXDB FIELD][,...]
A comma separated list of items to retrieve from the array and which are to be used as
.B fields
in InfluxDB. Otherwise same rules as for tags.
.It influxdb_fixed_tags=TAG[=VALUE][,...]
Optional comma separated list of fixed tags (and optionally with values) to save to InfluxDB.
.It influxdb_fixed_fields=FIELD[=VALUE][,...]
Optional comma separated list of fixed fields (and optionally with values) to save to InfluxDB.
.El
It is required to have at least one tag specified in either
.B influxdb_fields
or
.B influxdb_fixed_fields
.
.SS mqttbroker (N)
An MQTT broker supporting V3.1(.1) and V5 (lacking some functionallity).
.PP
.Bl -tag -width -indent
.It mqtt_server_port=PORT
TCP port to listen on (listens on all interfaces). Defaults to 1883.
.It mqtt_server_max_keep_alive=SECONDS
Maximum keep-alive value for clients, defaults to 30.
.It mqtt_server_retry_interval=SECONDS
Retry interval for QoS1 and QoS2 messages.
.It mqtt_server_close_wait_time=SECONDS
After disconnect, wait this many seconds before closing the socket (make client close first to avoid TIME_WAIT). Defaults to 1 second.
.El
.PP
The MQTT server follows the specifications from Oasis, but lacks support for the following (will be implemented shortly):
.PP
.Bl -tag -width -indent
.It UNSUBSCRIBE messages
.It Retained topics
.It Will topics
.It Encryption
.It Authorization
.El
.SS mqttclient (P)
An MQTT client supporting V3.1.1 and V5. The client will publish RRR messages it receives from other modules, and
other modules can read messages the client receives on subscribed topics.
.PP
.Bl -tag -width -indent
.It mqtt_server=HOST
Host name or IP of the broker to connect to. Defaults to localhost.
.It mqtt_server_port=PORT
TCP port on the server, defaults to 1883.
.It mqtt_client_identifier=IDENTIFIER
Client identifier to use. If left unspecified, broker pics one.
.It mqtt_connect_error_action={restart|retry}
Default action if connecting to the server failed. If set to
.B restart,
all RRR modules will be restarted after a few connection attempts (might cause messages to be lost). If set to
.B retry,
the client will keep trying to connect without any restart (messages will not be lost). Default action is to restart.
.It mqtt_connect_attempts=NUMBER OF ATTEMPTS
How many times we attempt connecting to the broker before giving up.
What we do when this number is reached depends on the setting
.B mqtt_connect_error_action.
One connection attempt lasts approximately 100ms. Must be 1 or more, defaults to 20.
.It mqtt_qos={0|1|2}
Default Quality of Service to use, defaults to 1.
.It mqtt_version={3.1.1|5}
Default MQTT protocol version to use, defaults to 3.1.1.
.It mqtt_publish_topic=TOPIC
Topic to use when publishing RRR messages without topic set in them.
If left unspecified, RRR messages without a topic will be dropped.
.It mqtt_publish_topic_force={yes|no}
Force use of the topic specified in
.B mqtt_publish_topic
and disregard any topic in RRR messages.
.It mqtt_publish_rrr_message={yes|no}
If set to yes, the client will send full RRR messages.
If set to no, only the measurement value of each RRR message will be sent as a string. Defaults to yes.
.It mqtt_publish_array_values={*|tag1[,tag2[,...]]}
Put all values from an array (*) or selected values (by tag) into the payload of PUBLISH messages. RRR
messages which does not contain an array are dropped. Any integer types will have big endianess. Cannot be used with
.B mqtt_publish_rrr_message=yes.
.It mqtt_subscribe_topics=TOPIC1[,TOPIC2[,...]]
MQTT topic patterns to subscribe to (if any).
.It mqtt_receive_rrr_message={yes|no}
Expect to receive RRR messages from the broker.
If set to yes, any messages received which are not RRR messages are dropped.
If set to no and protocol version is V3.1.1, any data in messages received are put into a new RRR message.
If set to no and protocol version is V5, type of the received message is auto-detected.
Defaults to no.
.It mqtt_receive_array=ARRAY DEFINITION
If set, expect to receive data arrays of specific formats in publish messages.
This option cannot be used with mqtt_receive_rrr_message=yes, however if protocol version is V5,
received RRR messages will still be auto-detected, and array parsing will not occur for these.
Multiple data array records may reside in a single PUBLISH message, one RRR message will be generated for each record. 
Refer to
.Xr rrr_post(1)
for syntax of array definitions.
Defaults to yes.
.El

.SH SEE ALSO
.Xr rrr(1),
.Xr rrr_post(1),
.Xr rrr_python3(5)
