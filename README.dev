# CUSTOM RRR MODULES

Writing modules requires knowledge about the C programming language. In attempt to avoid confusion, RRR distinguishes between
a `module` and an `instance`. A `module` is a plugin which has capabilities to do different jobs, and it is loaded when needed.
A module may have many `instances` of itself running at the same time with different configurations. Each instance has it's own thread.

This document describes two different types of modules

* User `C-modules` which are easy to implement, this should cover most needs
* *Native* RRR-modules which allow for heavy customization

## Getting started with C-modules

A C-module script or program basically has three functions defined, `config`, `source` and `processor`.

* `config` is called once to pass configuration parameters
* `source` is called repeatedly to spawn new messages
* `process` is called every time a message comes in from another module

If you wish to write a simple `C-module`, please check out the man page for `rrr.conf` which describes this in more detail. It's
basically so simple that it's no point coverering any technical details here.

### Confusion

To create confusion, there are two things called cmodule:

* The RRR-module `cmodule` which allows developers to write simple `C-modules`. It basically only one has file
  `src/modules/p_cmodule.c`. Custom C-modules are run from this module and are expected to be found in `src/cmodules/`.
* The internal `cmodule` framework in the RRR library which takes care of messages, loops, forks etc., this is divided into
  multiple files in `src/lib/cmodule/`

### How C-modules work

The basic thought is relatively simple, but the implementation is complex. Here are some keywords:

* For each C-module (or Perl-script etc.) a process is forked to run the script
* The fork, or `worker`, takes care of when the different three functions are called, and sends messages which has been
  spawned or processed to the parent, which then let's other modules pick them up
* The `parent`, which is a thread in the main RRR-process reads messages from other modules and sends messages to be
  processed to the worker
* The worker may choose not to send processed messages back, or to duplicate messages
* The communication between the parent thread and the worker  is performed on an "RRR Memory Map Channel". This method should
  both be fast when needed and not CPU-intensive when there's nothing to do. Fast means tens of thousands of messages
  (small ones that is) per second on an average home computer.
* When a C-module depends on external libraries, like Perl and Python, it is not allowed to call *any* of these library
  functions in the parent thread, all of this must be done in the worker after forking. These external libraries create
  all sorts of problems due to them using global variables and state. The only way to clean up properly
  after them is to stop the whole process, this is the main reason why the worker fork isis needed.

### Implementation of scripting language module

If you wish to implement another scripting language, consider having this written as a native RRR-module instead, this will give
better structure to the program. Check out the modules `perl5`, `python3` and `cmodule` and copy one of them. `cmodule` is
the simplest one, it has the least code and has no external dependencies.

The details around how this works is not documented, try to open the RRR source in an IDE like Eclipse and follow the function
calls to see what's going on. There's however very few function calls requried to be done from the native module itself.

## Getting started with native modules

To write a custom module, start by copying one existing module in the `src/modules/` directory. Update `Makefile.am` in the
same directory using the same naming convention as the other modules.

* To write a source module which only generates messages, copy the `dummy` module.
* To write a module which only processes data from other modules, copy the `raw` module.
* To write a module which both reads from other modules, processes it and lets other modules read from it, copy the `averager` module.

After a module is copied, replace all instances of the old name inside the file with your new name to avoid confusion.

All modules must provide an `init()` function which is used to provide information to Read Route Record about which functions
the module provides, its name and type. This can usually be left alone, just change the static `module_name` value to change
the informational name of the module. The `type` field, however, provides information about wether we expect a sender to
be specified or if we only are a source module (see `dummy` module vs `raw`);

The following module types are available:
- `RRR_MODULE_TYPE_SOURCE` - The module does not read from others, but it may be read from
- `RRR_MODULE_TYPE_PROCESSOR` - The module both reads from others and may be read from
- `RRR_MODULE_TYPE_DEADEND` - The module only reads from others
- `RRR_MODULE_TYPE_FLEXIBLE` - The module may be any of the three above depending on configuration
- `RRR_MODULE_TYPE_NETWORK` - The module is network oriented, it does not exchange messages with other modules

The `module_operations` struct provides pointers to our internal functions which other modules call. All values except `thread_entry
may be `NULL`. Reading modules should check whether a function really is available (not null) of senders before use, and be careful
about which types the return:
 
	struct module_operations {
		// Preload function - Run before thread is started in main thread context
		int (*preload)(...);
	
		// Main function with a loop to run the thread
		void *(*thread_entry)(...);
	
		// Post stop function - Run after thread has finished from main thread context
		void (*poststop)(...);
	
		// Test of configuration arguments (currently not used)
		int (*test_config)(...);
	
		// Inject any packet into buffer manually (usually for testing)
		int (*inject)(RRR_MODULE_INJECT_SIGNATURE);
	
		// Custom cancellation method (if we are hung and main wants to cancel us)
		int (*cancel_function)(...);
	};

In addition, one must specify the `load()` and `unload()` functions. These are called only once directly after loading the module and once just
before unloading it. That means they are not called for each instance. If a module is dependent on some external library which needs to
be initialized, this may be done in these functions.

The functions are called from different contexts and at different points in time.
- `preload`, `poststop`: Run before/after any threads starts and after all threads have stopped (unless they are ghosts, see below)
- `thread_entry`: The only function which is actually run by the thread of the instance. It should contain an infinite loop.
- `test_config`, `inject`: Used by test suite only
- `cancel_function`: Called by the watchdog thread of the instance if it hangs. If left unspecified, only `pthread_cancel` is called. 

## Writing to output buffer

All instances have an output buffer which other modules read from, also those which does not produce output in which this is simply not used.
The buffer provides locking and memory fences for data messages which are to move between threads. This is handled by the `message broker`.
Instances using the broker are called `costumers`.

The buffers of all modules are created prior to starting the modules. Whenever a function in the message broker is called, the existence of
the requested costumer is checked. If it does not exist, the call will fail. If it does exist, a reference count is incremented ensuring
the costumer is not deleted while it's being used.

All writes to the output buffer AND all writes to memory areas pointed to by data inside the buffer MUST happen inside the provided write methods.
Reads must also happen inside provided functions.

These methods are always available for an instance to use:

	rrr_message_broker_write_entry (
				INSTANCE_D_BROKER(data->thread_data), // Retrieves pointer to the message broker	
				INSTANCE_D_HANDLE(data->thread_data), // Gets the costumer handle of the current instance
				NULL,
				0,
				0,
				my_write_callback_function,
				&my_write_callback_data
	)

- The NULL and 0's are IP information which is not used in this case.
- The callback function must be provided by the instance, the actual writing happens here
- The callback data is used only by the callback function and instructs it on what to do

The callback function will receive a pre-allocated so called `ip buffer entry`. This struct holds IP address data (if any) and the message itself.
It also provides reference counting and locking.

Depending on how a module is written, we don't always know wether we should actually write to the buffer or not when calling a write functions. If
we do not wish to use the entry in the callback after all, the callback may return `RRR_MESSAGE_BROKER_DROP`. It's on the other hand also
possible to make the message broker call the callback again immediately if we wish to write another entry (or try again) by `RRR_MESSAGE_BROKER_AGAIN`.
These two may be ORed together. For severe errors, return `RRR_MESSAGE_BROKER_ERR`. This makes the write function also return and error (non-zero).

The IP buffer entry must be filled with an RRR message as other modules expects this. The message must only be allocated and written to inside the 
write callback to provide proper memory fencing.

Before the callback returns, the IP buffer entry MUST be unlocked using `rrr_ip_buffer_entry_unlock()`. Reference counting can usually be disregarded in
the write callback.

Some fast write methods are available to use for entries which already have been allocated inside a write function (and not modified afterwards),
but which we now wish to write to the output buffer without allocating a new entry. These functions are marked with `unsafe`.

	// Write to the output buffer
	rrr_message_broker_incref_and_write_entry_unsafe_no_unlock(...); 
	
	// Write to the delayed write queue of the output buffer
	rrr_message_broker_incref_and_write_entry_delayed_unsafe_no_unlock(...);
	
	// Removes entries one by one from the given collection and puts it into the output buffer
	rrr_message_broker_write_entries_from_collection_unsafe(...);

A delayed write can be performed while still being inside the callback of a write function or a poll callback (read further down) of the buffer we are writing to.

If we cannot guarantee that an IP buffer entry has been written to exclusively inside a write function, we must clone it when we add it to
the output queue:

	// Allocate new memory and copy to it
	rrr_message_broker_clone_and_write_entry(...);

## Reading/polling from other modules

The action of retrieving messages from the output buffers of other instances is called polling. This is done somewhat manually in every module inside
the main thread function. Here, an example of the minimum structure needed to perform polls in a module. The dots are where other code goes.

A poll structure holds information about who we should poll from. It might be costumized, although this is not recommended as it might confuse users.

	...
	
	// At the top of the thread functions
	struct rrr_poll_collection poll;
	rrr_poll_collection_init(&poll);

	// Make sure poll data is freed if we are cancelled
	pthread_cleanup_push(rrr_poll_collection_clear_void, &poll);
	
	...
	
	// Read the `senders` configuration parameter and store all senders into our poll struct
	rrr_poll_add_from_thread_senders(&poll, thread_data);
	
	...
	
	// Main thread loop
	while (...) {
			// Do the polling and call the callback if data was polled.
			if (rrr_poll_do_rrr_poll_delete (thread_data, &poll, my_poll_callback, 0) != 0) {
				break;
			}
	}
	
	...
	
	// At the end of the function, just before exiting
	pthread_cleanup_pop(1);
	
	...

Just as when we write, the IP buffer entry received in the callback must be unlocked prior to returning. The data will be destroyed
when returning from the callback, unless the reference count of the entry is incremented, which we must do if we wish to store
the entry inside our instance.

The IP buffer entry struct may be used directly in linked lists. An entry only exists in one instance at a time, this is enforced by
only 

## Thread state convention

Read Route Record creates one thread for every instance when it starts. All threads, when started, must first initialize their data
which other modules might use, and then wait for a START signal which RRR sends when all threads are initialized and
may read from each other. 

The threads should follow a strict pattern on how to initialize and close correctly. This has to be done to prevent readers to use
functions in other modules which are not ready when we start the program.

Threads which create forks should be started prior to network modules. Module priorities are:

0. `RRR_THREAD_START_PRIORITY_NORMAL` - No particular priority, started immediately.
1. `RRR_THREAD_START_PRIORITY_FORK` - Threads using this must set `RUNNING_FORKED` state after forks have been made
2. `RRR_THREAD_START_PRIORITY_NETWORK` - Uses sockets and should start after forking threads. Will receive start signal last.

The basic state flow of a module/thread is like this (see `threads.h` for internal names):

0. `FREE` - Thread is new
1. `STOPPED` - Thread has stopped
2. `INIT` - Thread is currently initializing its data and we have to wait for it to finish before we proceed
3. `INITIALIZED` - Thread has initialized its data and is waiting for start signal. When all threads reach
   this state, we tell them to start in a calculated order.
4. `RUNNING` - Thread sets this state after receiving start signal. If an instance is told to wait for another thread before starting, it will be started when the other thread sets `RUNNING`.
5. `RUNNING FORKED` - Thread sets this state after being started and any process forks are done (used by python and perl).

It is very important that a thread does not read from other threads before it has received the start signal.

A thread has to update a timer constantly using `update_watchdog_time()`, or else it will be killed by the watchdog after five seconds.

If one or more threads exit, all threads are stopped and restarted automatically.

## Thread data

When a thread/instance starts with the specified entry function, it receives a `rrr_thread_start_data` struct. It contains a pointer to the
command line argument struct from the main program (`cmd_data` struct), data from the configuration file (`rrr_instance_settings`) and a `private_arg` pointer which should be casted in the 
thread to `instance_thread_data` struct. 

There is a slot of 8kB freely available in `instance_thread_data` for a thread to use which does not have to be de-allocated on exit,
it is called `char private_memory[RRR_MODULE_PRIVATE_MEMORY_SIZE]`. To use this, create a custom struct and point it to the `private_memory`
address.

If your module uses locks and buffers, these should be placed in this memory. DO NOT destroy locks when exiting the module if they are used
by one or more poll functions.

Use the pthread framework `pthread_cleanup_push()` and `pthread_cleanup_pop()` to clean up a threads data on exit, look in the
existing modules how they do this. This will make sure data is cleaned up also if the thread is cancelled the hard way. If a thread
hangs on I/O and doesn't exit nicely, it will be left dangling in memory untill it recovers upon which it will clean up its memory.
A new instance will be created insted, and therefore we MUST NOT use statically allocated data in the module which might cause
corruption. Use the private memory provided instead.
