# README FOR VOLTAGE LOGGER
## ABOUT

Voltage logger is designed to read data from sensors and logging it in a threaded and
buffered fashion, ensuring that no measurement is lost due to IO problems. Data is
routed between custom modules by having "senders" specified for some of them, instructing
them who to read from. Source modules should have a buffer which they write to
independently from their readers.

## USAGE

To start the program with module `raw` reading from `voltmonitor`, run:

`vlogger module=raw,voltmonitor`

To start the program with `raw` reading from two modules:

`vlogger module=raw,voltmonitor,dummy`

To start a chain with three modules `voltmonitor->averager->raw`:

`vlogger module=raw,averager module=averager,voltmonitor`

A module can also be specified on its own:

`vlogger module=custom_module`


## MODULES

### raw (drain output from other modules)

`vlogger module=raw,dummy`

Read output from any module and delete it. If debuglevel 2 is set, we print the values on the screen. We should use this module if
some module produces output which we don't intend to use, so that the modules output buffer doesn't eat up memory.

### dummy (generate dummy measurements)

`vlogger module=raw,dummy`

Create point measurements with current timestamp as value at some interval. 

### voltmonitor (USB voltmeter driver)

`vlogger module=raw,voltmonitor vm_calibration=1.020 vm_channel=2`

Specifiy channel (1 or 2) and/or calibration (factor which scales input).

### averager (create averages from voltmonitor)

`vlogger module=averager,voltmonitor module=raw,averager [avg_preserve_points={yes|no}] [avg_timespan=SECONDS]Â [avg_interval=SECONDS]`

Create MAX/MIN/AVG measurements at intervals with input from voltmonitor.

- `avg_timespan`: How long period to make an average from, default is 15
- `avg_interval`: How often to make an average, default is 10
- `avg_preserve_points`: Preserve individual measurements and pass to next module, default is no
	
### ipclient (Send UDP packets to server and wait for ACK)
`vlogger module=ipclient,dummy ipclient_server=10.0.2.2 ipclient_server_port=5555`

### blockdev (log messages to block device or file)
`vlogger module=blockdev,voltmonitor device_path=DEVICE always_tag_saved={yes|no}`

Specify block device or file to log entries, this storage must first be initialized
using Block Device Logger command line application.

Messages stored on the device will be re-read into memory on start-up untill they are
tagged as saved. The mysql-module can generate such tag messages, or one can specify
always_tag_saved=yes, in which all messages are tagged immediately when first stored.
This should be specified if there are no modules listending to blockdev.

### mysql (store messages to database)
Mysql reads data from ipserver and stores to a database.

`vlogger module=mysql,ipserver module=ipserver,mysql [mysql_no_tagging={yes|no}] [mysql_host=HOST] [mysql_port=PORT] mysql_user=USER mysql_password=PASSWORD mysql_db=DATABASE mysql_table=TABLE`

Unless `mysql_no_tagging` is set, mysql generates TAG messages which can be processed
by the blockdev module, these are sent back to the originating IP address.

A table can should this, but it may have additional columns:

	CREATE TABLE `entries` (
		`timestamp` bigint(20) UNSIGNED NOT NULL,
		`source` varchar(50) NOT NULL,
		`class` tinyint(3) UNSIGNED NOT NULL,
		`time_from` bigint(20) UNSIGNED NOT NULL,
		`time_to` bigint(20) UNSIGNED NOT NULL,
		`value` bigint(20) NOT NULL,
		`message` varchar(255) NOT NULL,
		`message_length` int(10) UNSIGNED NOT NULL
	) ENGINE=InnoDB DEFAULT CHARSET=latin1;

The `source` is the IP address of the sender. The first three columns should be defined
as `PRIMARY KEY` or a `UNIQUE` key to prevent duplicates. Voltage logger uses `REPLACE INTO` to
place data into the table.

### ipserver (receive messages from ipclient)
`ipserver` listens for messages from `ipclient` on port 5555 and passes them on to the next module (only mysql
is compatible). We send ACK messages back for every message received. Downstream modules (usually mysql)
can generate messages which we also send back.

`vlogger module=mysql,ipserver module=ipserver,mysql`

### controller (coordinate messages between averager, blockdev and ipclient)

The intention of this module is to store messages locally untill they are recevied and stored by a remote
server, even in case of a power failure.

`vlogger module=averager,voltmonitor module=controller,blockdev,ipclient,averager module=ipclient,controller module=blockdev,controller`

This will create a network like this:

	                               Local host                             |           Remote host 
	----------------------------------------------------------------------|-----------------------------------
	                                                                      |
	                                   +------------+     +----------+    | (see ipserver/mysql paragraphs)
	                                   |            | <=> | blockdev |    |
	+-------------+    +----------+    |            |     +----------+    |
	| voltmonitor | => | averager | => | controller |                     |
	+-------------+    +----------+    |            |     +----------+    |    +----------+     +-------+
	                                   |            | <=> | ipclient | <=====> | ipserver | <=> | mysql |
	                                   +------------+     +----------+    |    +----------+     +-------+
	----------------------------------------------------------------------|-----------------------------------

- All messages from `averager` are sent both to `blockdev` and `ipclient`
- All messages from `blockdev` are sent to `ipclient`
- `TAG` messages from `ipclient` are sent to `blockdev`

This setup will save messages to `blockdev` and keep on sending them through `ipclient` untill a final
`TAG` message is received.

## DEBUG LEVELS

The current debug level is common for all modules and specified like this:

`vlogger debuglevel=3`

`debuglevel` is a sum of one or more of these values, or zero. It is also possible to specify `all`:
* `0` - Only errors are printed
* `1` - Information about starting/stopping of modules (low rate)
* `2` - Running information from modules, they tell what they do on different steps (rate depends on traffic)
* `4` - Hex printing of messages and other data debugging (high rate)
* `8` - Debug locking and thread states (very high rate)
* `16` - Alive messages from some modules also when they are idle (very high rate)

For instance `debuglevel=3` means that debug level `1` and `2` is activated.

## INTERNAL MESSAGE TYPES

An internal message contains some metadata and a class specifier which tells us what kind of
information and/or value it stores.
* Metadata for a message:
  * `Timestamp from` and `Timestamp to`
    Specifies the duration of the message. The timestamps can be equal if a message has no
    timespan.
    * `MSG`
  * `Class`
    The message class which describes what kind of information it stores:
    * `POINT`: Measurement at one time instance
    * `AVG`, `MIN`, `MAX`: Average, minimum or maximum measurement over a timespan. In the case
      of `MIN` or `MAX`, the actual time of the minimum or maximum measurement is store in
      `Timestamp to`. `Timestamp from` contains the end time of the measurement timestamp, and
      the start time can be found by checking the from-timestamp of the previous measurement.
    * `INFO`: Usally information in text, for instance to log error conditions.
  * `Data`
    Textual representation of the data in the message
  * `Numeric value`
    Messages containing measurements store these both in text format and binary format to make
    them easier to process. When sent over network, this numeric representation may be lost, but
    it can be restored from the text field.
* Types of messages
  * `MSG`: An actual message with a measurement or information
  * `ACK`: Acknowledgement of packet recieval when it is sent over network.
  * `TAG`: These messages usually inform that a message has been safely stored remotely.
`ACK` and `TAG` messages contain the full original message (maybe except for the numeric value)
making modules able to match them with the original message.

## CUSTOM MODULES

Writing modules requires knowledge about the C programming language.

### Getting started

To write a custom module, start by copying one existing module in the `src/modules/` directory. Update `Makefile.am` in the
same directory using the same naming convention as the other modules.

* To write a source module which only generates messages, copy the `dummy` module.
* To write a module which only processes data from other modules, copy the `raw` module.
* To write a module which both reads from other modules, processes it and lets other modules read from it, copy the `averager` module.
* The `controller` module gives an example on how to use multiple buffers and route different messages between modules.

After a module is copied, replace all instances of the old name inside the file with your new name to avoid confusion.

All modules must provide an `init()` function which is used to provide information to Voltage Logger about which functions
the module provides, its name and type. This can usually be left alone, just change the static `module_name` value to change
the informational name of the module. The `type` field, however, provides information about wether we expect a sender to
be specified or if we only is a source module (see `dummy` module vs `raw`);

The `module_operations` struct provides pointers to our internal functions which other modules call. All values except the first
may be `NULL`. Reading modules should check wether a function really is available (not null) of senders before use, and be careful
about which types the return:
 
	struct module_operations {
        	void *(*thread_entry)(...) // Main function for starting the thread
        	int (*poll)(...)           // Return messages without deleting them from the buffer
        	int (*print)(...)          // Currently not used in any modules (but may be used)
        	int (*poll_delete)(...)    // Return vl_message structs 
        	int (*poll_delete_ip)(...) // Return ip_buffer_entry structs (same as vl_message but with IP information at the end)
	};

If you specify `_delete`-functions, you should remove entries from the buffer after passing them on (but not free the actual data pointer). 

When using a poll function of another module, one must specify a callback function which will receive the data from the sender.

Since most poll functions use buffers, they require a `fifo_callback_args` struct as argument (defined in `buffer.h`). This contains two pointers:
- `source` : Expected by some modules to contain a pointer to the `module_thread_data` struct of the reader
- `private_data` : Used if another pointer is needed to arrive in the callback function

If you need more functions, add them to the struct in `modules.h` and make sure to set the new values to `NULL` in all modules.

### Thread state convention

Voltage Logger creates one thread for every module when it starts. All threads, when started, must first initialize their data
which other modules might use, and then wait for a START signal which Voltage Logger sends when all threads are initialized and
may read from each other. 

The threads should follow a strict pattern on how to initialize and close correctly. This has to be done to prevent readers to use
functions in other modules which are not ready when we start the program.

The basic state flow of a module/thread is like this (see `threads.h` for internal names):

0. `FREE` - Thread slot is currently free
1. `STOPPED` - Thread has stopped
2. `INIT` - Thread is currently initializing its data and we have to wait for it to finish before we proceed
3. `INITIALIZED` - Thread has initialized its data and is waiting for start signal. When all threads reach
   this state, we tell them to start.
4. `RUNNING` - Thread sets this state after receiving start signal.
5. `ENCOURAGE STOP` - Set by the thread watchdog if it wants a thread to stop, for instance if the program is to
   exit. The thread should check for this at least a couple of times a second and exit if the state is set. If
   a thread doesn't respond to this, it will be cancelled.
6. `STOPPING` - A thread should set this state if it detected `ENCOURAGE STOP` and is about to exit.

It is very important that a thread does not read from other threads before it has received the start signal.

A thread has to update a timer constantly using `update_watchdog_time()`, or else it will be killed by the watchdog after five seconds.

If one or more threads exit, all threads are stopped and restarted automatically.

### Thread data

When a thread starts with the specified entry function, it receives a `vl_thread_start_data` struct. It contains a pointer to the
command line argument struct from the main program (`cmd_data` struct) and a `private_arg` pointer which should be casted in the 
thread to `module_thread_data` struct. 

There is a slot of 8kB freely available in `module_thread_data` for a module to use which does not have to be de-allocated on exit,
it is called `char private_memory[VL_MODULE_PRIVATE_MEMORY_SIZE]`. To use this, create a custom struct and point it to the `private_memory`
address.

If your module uses locks and buffers, these should be placed in this memory. DO NOT destroy locks when exiting the module if they are used
by one or more poll functions.

Use the pthread framework `pthread_cleanup_push()` and `pthread_cleanup_pop()` to clean up a threads data on exit, look in the
existing modules how they do this. This will make sure data is cleaned up also if the thread is cancelled the hard way. If a thread
hangs on I/O and doesn't exit nicely, it will be left dangling in memory untill it recovers upon which it will clean up its memory.
A new instance will be created insted, and therefore we MUST NOT use statically allocated data in the module which might cause
corruption. Use the private memory provided instead.

### Buffers

Voltage Logger provides a framework for buffering data before it is read by other modules, or buffer data from other modules before
processing. A module is not required to be buffered, it can simply generate it's data whenever a poll function is called. However
if the module depends on I/O, it is generally a good idea to use the main thread function to put data in a buffer which others then
read from.

To create a buffer, place a `fifo_buffer` struct in the private memory area and initialize it with `fifo_buffer_init`. This MUST be
done BEFORE the thread sets `INITIALIZED` state. Write a cleanup function which calls `fifo_buffer_invalidate` and push it to
the pthread cleanup stack (see Thread section above). This function deletes all entries in the buffer and sets the invalid flag
which informs users that the buffer is no longer to be used. DO NOT destroy the buffer or zero it's data.

A number of functions are available for reading and writing to a buffer. They return `0` if the buffer was valid, and `1` if the buffer
was invalid. Poll functions which reads from a buffer should also return this value, and it should be checked by readers which should
quit if the buffer was invalid. 

Buffer read functions require a callback function to be specified to receive the data. the callback function can return the following
values to inform the buffer framework about different situations. Not all are valid for all functions (see below). The values may be
ORed together. The callback function is called once for every entry found.

0. `FIFO_SEARCH_KEEP`	- Everything was OK 
1. `FIFO_SEARCH_ERR`	- Some error occured, print error message
2. `FIFO_SEARCH_STOP`	- We don't want to be called again, stop processing.
4. `FIFO_SEARCH_GIVE`	- We have taken control of the data, remove its entry from the buffer. 

The `fifo_read_clear_forward` function will continue to pass on data to the callback regardless of return value. The callback MUST ALWAYS
take care of the data.

The buffer doesn't care about the type of data it stores, make sure that the data is casted to the same type in the reader as the writer puts in.
The `size` arguments may be used to check if a type is correct or not. 

See `buffer.h` for function syntax, and look in existing modules for examples on usage. The locking functions should not be called.

#### `fifo_read_clear_forward`
This function clears the whole buffer and passes each entry one by one to a callback function. The callback
function MUST take care of the memory returned and `free()` it when no longer used, or put it in another buffer. This function is very
efficient as it only locks the buffer for a minimal amount of time, to set the  global pointers to `NULL`.

The callback function may put data back into the same buffer using a write function, since no lock is held. This can be done for
instance on error conditions.

All return values from the callback function are ignored, but if one or more calls return error, `fifo_read_clear_forward` returns 1.

All entries are read from and removed from the buffer untill the entry pointed to by `last_element` is reached. If this is NULL, all entries are
processed.  

#### `fifo_search`
This function passes all elements from a buffer to a callback function untill it returns `FIFO_SEARCH_STOP` or `FIFO_SEARCH_ERR`. If it receives
`FIFO_SEARCH_GIVE`, it removes the entry from the buffer and the reader must take care of the data.

#### `fifo_write`
Puts new data to the end of the buffer.

#### `fifo_buffer_write_ordered`
Puts data in the buffer ordered by the `order` argument.

#### `fifo_clear_order_lt`
Clears the beginning of a buffer up to the first entry which has an order value equal to or greater than the `order_min` argument. It is most
reasonable to only use ordered writes before using this function. No callback function is needed.

## CONTACT

github.com/atlesn/voltagelogger

